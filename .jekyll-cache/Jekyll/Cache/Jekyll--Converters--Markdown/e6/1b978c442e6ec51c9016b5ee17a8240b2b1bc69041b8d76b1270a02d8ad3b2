I"Æ%<p>Hemos venido hablando de las caracter√≠sticas que componen a un sistema REST. En el √∫ltimo art√≠culo <a href="/2019/07/04/entendiendo-rest-arquitectura-cliente-servidor.html">hablamos de la arquitectura cliente-servidor</a>. Esta es la primera caracter√≠stica fundamental de un sistema REST. Ahora pasemos a la siguiente caracter√≠stica-limitante que Thomas Fielding establece para los sistemas REST: <strong>conexi√≥n sin estado</strong>.</p>

<h2 id="qu√©-es-el-estado-de-un-sistema">¬øQu√© es el estado de un sistema?</h2>

<p>El estado de una aplicaci√≥n son todos los datos que usa para operar en un momento determinado.</p>

<p>Como ejemplo podemos pensar en una aplicaci√≥n de ventas en l√≠nea. El estado de esta aplicaci√≥n, para un usuario espec√≠fico son sus datos de identificaci√≥n, su bolsa de compras y los productos que ha estado viendo o que tiene en su lista de deseos, as√≠ como datos que no son identificables directamente desde la interfaz de usuario como los tokens de sesi√≥n, su historial de visita de las p√°ginas y productos (piensa en Amazon) y los productos que ha comprado anteriormente en esta p√°gina.</p>

<p>Todos estos datos necesarios para operar tanto a nivel interno como para la interfaz de usuario son el estado de la aplicaci√≥n para este usuario. <strong>Puedes entender el estado como el contexto de una aplicaci√≥n</strong>. Todas las aplicaciones y programas usables tienen uno. Entonces, ¬øa qu√© nos referimos con conexiones sin estado?</p>

<h2 id="conexi√≥n-sin-estado">Conexi√≥n sin estado</h2>

<p>Dando por supuesto que estamos trabajando en un sistema con arquitectura de red <a href="/2019/07/04/entendiendo-rest-arquitectura-cliente-servidor.html">cliente-servidor</a>, las dos partes comparten la informaci√≥n (el estado) necesaria para realizar las operaciones. La pregunta es: ¬øen qu√© lado mantengo esta informaci√≥n durante la operaci√≥n? Damos por supuesto que el almacenamiento de informaci√≥n a largo plazo est√° localizado en alg√∫n lado del servidor. Pero en el momento de la operaci√≥n, ¬øqui√©n mantiene estos datos memoria operativa?</p>

<p>En el ejemplo del que hablamos: ¬øqui√©n mantiene en memoria la bolsa de compras del usuario, el cliente (el navegador web) o el servidor? Cualquiera de los dos podr√≠a llevarlo a cabo. Veamos los dos casos, empecemos por una conexi√≥n que ‚Äúrecuerda‚Äù el estado.</p>

<p>Imag√≠nate la siguiente conversaci√≥n:</p>

<ul>
  <li>Cliente(C): Vamos a empezar a trabajar con el usuario <em>hectorip</em></li>
  <li>Servidor(S): De acuerdo</li>
  <li>C: Dame su bolsa de compras</li>
  <li>S: Tiene estos 5 art√≠culos guardados</li>
  <li>C: Comprar todos los art√≠culos de su bolsa</li>
  <li>S: Ok, ser√°n $500</li>
  <li>C: el cliente quiere pagar</li>
  <li>S: le he cobrado todo lo de su bolsa</li>
</ul>

<p>El tipo de conversaci√≥n que acabamos de ver ser√≠a una <strong>conexi√≥n con estado</strong>: cada uno de los mensajes depende del mensaje anterior para poder entender de qu√© est√°bamos hablando. Intenta leerla de regreso y lo notar√°s.</p>

<p>Ahora veamos c√≥mo ser√≠a un conversaci√≥n que no recuerda los mensajes anteriores:</p>

<ul>
  <li>C: Dame la bolsa de compra de <em>hectorip</em></li>
  <li>S: hectorip tiene estos 5 art√≠culos en su bolsa</li>
  <li>C: hectorip quiere comprar todos los art√≠culos de su bolsa</li>
  <li>S: Ok, ser√°n $500 por todos los art√≠culos de la bolsa de compra</li>
  <li>C: hectorip quiere realizar un pago por $500 por los art√≠culos en su bolsa de compras</li>
  <li>S: He cobrado $500 a hectorip por el pedido de los art√≠culos en su bolsa de compras</li>
</ul>

<p>Si revisamos la conversaci√≥n anterior, podemos entender cada mensaje le√≠do individualmente, sin necesitar el contexto completo de la conversaci√≥n.</p>

<p>La primera conversaci√≥n (conexi√≥n con estado) tiene algunas ventajas claras:</p>

<ul>
  <li>Los mensajes son m√°s cortos</li>
  <li>La conversaci√≥n es m√°s flu√≠da</li>
  <li>Se transfiere menos informaci√≥n de un lado a otro</li>
</ul>

<p>Pero tambi√©n tiene desventajas. ¬øQu√© pasa si esta conversaci√≥n se interrumpe y se intenta retomar? <em>Hay que empezar la conversaci√≥n desde cero.</em> ¬øQu√© pasa si el servidor, por alg√∫n error olvida de lo que est√°bamos hablando? <em>Hay que reiniciar la conversaci√≥n.</em> ¬øQu√© pasa si quiero continuar la compra en otro servidor? <em>Hay que reiniciar la conversaci√≥n con el nuevo servidor.</em></p>

<h1 id="caracter√≠sticas-de-conexi√≥n-sin-estado">Caracter√≠sticas de conexi√≥n sin estado</h1>

<p>Hablemos de las caracter√≠sticas de una conexi√≥n sin estado.</p>

<p>La primera caracter√≠stica es que <em>no necesitamos</em> que la conexi√≥n a nivel de sesi√≥n de red sea persistente, es decir, que se mantenga un canal de comunicaci√≥n abierto que pueda mantener en memoria la informaci√≥n de los procesos actuales.</p>

<p>Segundo, no podemos (ni debemos) asumir que el servidor mantendr√° los datos del cliente autom√°ticamente por medio de reconocer al cliente. En cada una de las peticiones que se hacen al servidor, <strong>deben venir todos los datos necesarios para que el servidor mantenga realice la operaci√≥n</strong>, no se puede confiar en que las peticiones anteriores transfirieron esa informaci√≥n y no es necesario repetirla.</p>

<p>Hasta ahora parece que esto presenta m√°s problemas que ventajas. Revisemos por qu√© alguien querr√≠a trabajar con un sistema as√≠.</p>

<h2 id="ventajas-de-mantener-el-servidor-sin-estado">Ventajas de mantener el servidor sin estado</h2>

<ol>
  <li>
    <p><strong>Replicaci√≥n de servidores</strong>. Al no tener que mantener el estado o conexiones persistentes con una instancia del servidor, una conexi√≥n sin estado puede permitir que la petici√≥n sea atendida por cualquier instancia del c√≥digo del servidor que tenga el mismo c√≥digo que las peticiones anteriores, ya que toda la informaci√≥n necesaria para atender esas peticiones estar√° incluida.</p>
  </li>
  <li>
    <p><strong>Escalabilidad</strong>. Esto es una consecuencia inmediata de la ventaja anterior: poder replicar los servidores permite distribuir la carga entre muchas computadoras y aplicar t√©cnicas de balanceo para poder atender a muchos m√°s clientes de lo que se podr√≠a en un sistema que requiera mantener estados.</p>
  </li>
  <li>
    <p><strong>Servicios m√°s sencillos</strong>. Quitarle la responsabilidad de mantener el contexto de las operaciones actuales a los servicios hace que su c√≥digo sea m√°s sencillo y por lo tanto m√°s mantenible.</p>
  </li>
  <li>
    <p><strong>Menos carga en los servidores</strong>. Al no tener que mantener conexiones persistentes, ni tener que mantener procesos o memoria relacionada con los clientes con los que est√° operando, se reduce la carga en memoria operativa de los servidores (te√≥ricamente). Esto tambi√©n implica que el servidor ni siquiera tiene que estar corriendo mientras no est√© activamente respondiendo una petici√≥n (como las funciones lambda).</p>
  </li>
</ol>

<p>La siguiente imagen ilustra una t√©cnica com√∫n para atender a muchos clientes.</p>

<p><img src="https://res.cloudinary.com/hectorip/image/upload/c_scale,w_1200/v1564887852/PNG_image-428CDB12FF65-1_ojrpoo.png" alt="Diagrama de replicaci√≥n de servidores" /></p>

<h2 id="desventajas">Desventajas</h2>

<ol>
  <li>
    <p><strong>Complejidad de las peticiones</strong>. La complejidad de las peticiones aumenta al necesitar mantener en el cliente toda la informaci√≥n necesaria para reconstruir el estado en cada petici√≥n en un servidor desde cero. Por lo tanto, la complejidad de los clientes aumenta. y el tama√±o de las peticiones se incrementa.</p>
  </li>
  <li>
    <p><strong>Mayor carga en la red</strong>. Como las peticiones son m√°s complejas y generalmente contienen m√°s informaci√≥n para poder recuperar el contexto efectivamente, el viaje de informaci√≥n en la red es mayor en tama√±o.</p>
  </li>
</ol>

<h2 id="conexiones-que-mantienen-estado">Conexiones que mantienen estado</h2>

<p>En los √∫ltimos a√±os la mayor√≠a de las conexiones que se levantan en programas creados con la arquitectura cliente-servidor son creados con conexiones que no mantienen el estado. Sin embargo, tambi√©n se puede mantener una conexi√≥n con estado en la arquitectura cliente-servidor. Hay varias formas de lograr esto, pero la principal caracter√≠stica es que debe haber una manera de relacionar al cliente que est√° solicitando los servicios con el servidor que est√° atendi√©ndolo, por lo general la manera de hacerlo es con conexiones persistentes que se mantienen abiertas mientras el proceso de uso de los servicios dura.</p>

<p>Esto viene con sus propios retos, pero tecnolog√≠as actuales como <a href="/2019/06/02/por-que-deberias-aprender-elixir.html">Elixir</a>, Phoenix y los WebSockets hacen el camino m√°s f√°cil. En otro post hablaremos de c√≥mo podemos aprovechar esta arquitectura y en qu√© casos nos conviene.</p>

<h2 id="conclusi√≥n">Conclusi√≥n</h2>

<p>La segunda caracter√≠stica definida de los sistemas REST es importante porque permite que los servicios sean m√°s confiables, disponibles y flexibles en tama√±o (escalables). Como cada decisi√≥n que se toma en el desarrollo, esta viene con sus propias desventajas: al hacer m√°s complejas las peticiones, la base de c√≥digo es m√°s dif√≠cil de mantener en general (del lado del cliente), pero permite caracter√≠sticas importantes en los sistemas que tienen que atender a una gran cantidad de clientes.</p>

<p>En el siguiente art√≠culo hablaremos de la tercera caracter√≠stica de los sistemas REST: la capacidad de ser cachear informaci√≥n.</p>
:ET