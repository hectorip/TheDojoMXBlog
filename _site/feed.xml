<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://blog.thedojo.mx/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.thedojo.mx/" rel="alternate" type="text/html" /><updated>2020-02-04T19:46:38-06:00</updated><id>https://blog.thedojo.mx/feed.xml</id><author><name>Héctor Patricio</name><uri>https://github.com/hectorip</uri></author><entry><title type="html">¿Qué es DevOps?</title><link href="https://blog.thedojo.mx/2020/01/16/que-es-devops.html" rel="alternate" type="text/html" title="¿Qué es DevOps?" /><published>2020-01-16T00:00:00-06:00</published><updated>2020-01-16T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2020/01/16/que-es-devops</id><content type="html" xml:base="https://blog.thedojo.mx/2020/01/16/que-es-devops.html">&lt;p&gt;&lt;strong&gt;DevOps&lt;/strong&gt; es un término de recientemente creación (2013) que representa un cultura de trabajo enfocada en resolver los problemas que han sido persistentes en la entrega y servicio en el área de productos tecnológicos.&lt;/p&gt;

&lt;p&gt;En este artículo platicaremos qué significa y sus fundamentos.&lt;/p&gt;

&lt;p&gt;Adelanto: DevOps no es un rol, una palabra mágica y mucho menos automatización de servidores.&lt;/p&gt;

&lt;h2 id=&quot;por-qué-importa&quot;&gt;¿Por qué importa?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;En las eras económicas anteriores, los negocios creaban valor moviendo átomos. Ahora crean valor moviendo bits. - Jeffrey Snover&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ahora todas las empresas son empresas de tecnología. Las que no aprovechan la tecnología ya están siendo superadas por las que sí lo hacen. Y las que lo hacen mal en su momento serán superadas por las que usan mejor la tecnología.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Cada industria y compañía que no traiga el software al corazón de su negocio será cambiada radicalmente sin previo aviso. - Jeffrey Immelt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Así que es importante que las empresas aprendan a manejar lo mejor posible la tecnología y a crear valor o aumentar el valor que producen mediante ella.&lt;/p&gt;

&lt;h2 id=&quot;los-problemas&quot;&gt;Los problemas&lt;/h2&gt;

&lt;p&gt;Si has trabajado en desarrollo de software, infraestructura o en el área de IT de alguna empresa tal vez no necesito contarte esto. Todo lo relacionado con productos digitales está plagado de proyectos no cumplidos en tiempo, nunca terminados, pasados de presupuesto, atención a clientes internos extremadamente deficiente, etc.&lt;/p&gt;

&lt;p&gt;No conforme con eso hay millones de historias de terror de cómo los negocios no se interesan en lo mínimo por mejorar estas áreas, sólo exigiendo cada vez más cosas y poniendo fechas irrazonables.&lt;/p&gt;

&lt;p&gt;Otras historias cuentan los actos heróicos que las personas que trabajamos en estas áreas hemos tenido que hacer para cumplir con los compromisos adquiridos: trabajar toda la noche por varios días seguidos, cambios de último momentos, largas horas en despliegues y re-establecimiento de servicios, etc. O se descubre que el sistema no cumple con los requerimientos legales de protección información y ahora hay que trabajar horas extras para cumplirlo.&lt;/p&gt;

&lt;p&gt;Y por último la vista del lado de la operación del negocio: cada que se va a poner en producción un cambio, un nuevo producto o se va a actualizar algo todos temen que algo catastrófico pase con cierta razón. Ha pasado que, por culpa de estos cambios, los sistemas que soportan la operación diaria se caen por horas haciendo perder al negocio clientes, dinero y reputación.&lt;/p&gt;

&lt;p&gt;Todos estos problemas son lo que DevOps ataca con 3 principios o “tres caminos”. Pero para habilitar esto, se necesita algo de la organización.&lt;/p&gt;

&lt;h2 id=&quot;todos-los-involucrados-trabajan-para-lo-mismo&quot;&gt;Todos los involucrados trabajan para lo mismo&lt;/h2&gt;

&lt;p&gt;Sobre todo en empresas grandes, donde es más común dividir en departamentos debido a la gran cantidad de trabajo disponible, es normal que &lt;strong&gt;cada departamento busque sólo sus propios intereses&lt;/strong&gt; y cumplir con sus métricas de desempeño sin poner en primer lugar lo más importante: la producción de valor para el negocio en general.&lt;/p&gt;

&lt;p&gt;Así que la primera precondición para que se pueda alcanzar verdadera productividad es que los involucrados comprendan que todos trabajan con el fin de crear cosas de valor para que el negocio siga funcionando y pueda hacerlo cada vez mejor. Esto implica eliminar la burocracia, las guerras entre departamentos y la reducción de trabajo que sólo se hace por demostrar que se tiene algo que hacer como tristemente ha estado marcado por este estigma el departamento de Seguridad de la Información o su equivalente.&lt;/p&gt;

&lt;p&gt;Si la actividad qu se está haciendo no contribuye de alguna forma a crear valor para el negocio debería ser eliminada.&lt;/p&gt;

&lt;p&gt;Esta condición por sí misma es difícil de cumplir y sin ella no es posible lograr las demás. ¿Quiénes son los encargados poner las condiciones para que se cumpla? La dirección. La dirección de la empresa tiene la responsabilidad de elegir personas razonables, buenas en sus campos y dispuestas a cooperar para que la empresa o el proyecto progresen más allá de su ego. Repito, &lt;strong&gt;sin esto lo demás es imposible o inútil&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Una vez cumplida la precondición de cooperación con personas dispuestas y hábiles, podemos hablar de los tres caminos.&lt;/p&gt;

&lt;h2 id=&quot;el-primer-camino-flujo&quot;&gt;El primer camino: Flujo&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1579042628/4E94ED23-0268-4F59-A101-1CF009540E01_pssljp.jpg&quot; alt=&quot;Primer camino de DevOps&quot; /&gt;&lt;/p&gt;

&lt;p&gt;El primer principio de DevOps establece que debe haber un flujo constante de valor en el área de tecnología de información o de sistemas, como lo quieras llamar. Algo de valor es todo aquello que permite al negocio seguir operando o incrementar los beneficios que obtiene de las operaciones.&lt;/p&gt;

&lt;p&gt;El objetivo principal es &lt;strong&gt;minimizar el tiempo&lt;/strong&gt; que tarda una característica/producto/servicio en entregarse desde que solicita hasta que empieza a cumplir con su función.&lt;/p&gt;

&lt;p&gt;Debido a que el desarrollo de software es una actividad poco predecible, DevOps se enfoca en la parte de la cadena de entrega de valor que va desde que el área de desarrollo termina algo hasta que es puesto en manos de los usuarios finales. Pero no le interesa sólo eso, ya que las personas encargadas del desarrollo deben seguir ciertas prácticas para facilitar el resto del camino.&lt;/p&gt;

&lt;p&gt;Acelerar esta entrega beneficia en gran manera a la forma en que se desarrolla software de calidad.&lt;/p&gt;

&lt;p&gt;Si estás en una empresa pequeña o en una &lt;em&gt;startup&lt;/em&gt; puede que seas tú mismo el que desarrolle y tenga que mantener los programas en operación (producción). Así que reducir la fricción entre estas dos actividades te beneficiará aún más.&lt;/p&gt;

&lt;p&gt;¿Qué prácticas permiten lograrlo?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Hacer el trabajo visible.&lt;/strong&gt; La mayoría del trabajo que realizamos al hacer productos digitales es muy difícil de estimar, tanto en dificultad como en cantidad.
Es por eso que debe haber una manera física de ver el trabajo, como lo habría en un fábrica que realiza productos físicos: si una estación de trabajo tiene demasiado material inmediatamente se notará.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Reducir y limitar el trabajo en progreso.&lt;/strong&gt; Mientras más actividades sin terminar existan, más difícil es administrarlas y notar todo el trabajo pendiente. Tener pocas actividades en progreso permite &lt;strong&gt;calcular mejor&lt;/strong&gt; cuánto tardará en terminarse un nuevo requerimiento y atender los errores más rápidamente. Siguiendo con el ejemplo de la fábrica física: existe un límite físico para el material que puede esperar en una estación de trabajo.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Establecer procesos&lt;/strong&gt;. Cada uno de los cambios o actividades solicitadas debe pasar por un proceso de revisión que determine si provee valor para el negocio en caso de completarse. Esto implica mantener en algún lado el registro de las tareas solicitadas y su estado actual.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Reducir el tamaño del lote trabajo&lt;/strong&gt;. Cuando vamos a entregar algo generalmente agrupamos varias piezas de trabajo para “entregarlas más eficientemente”. Pero en realidad mientras más pequeño sea este lote de trabajo (idealmente de una tarea) mejor se hace la entrega.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Identificar y mejorar las limitantes&lt;/strong&gt;. En todo proceso de trabajo hay puntos que hacen que toda la cadena de entrega de valor sea más lenta. Estos puntos son las limitantes. Para mejorar toda la cadena primero hay que identificarlos y después mejorar su eficiencia para mejorar todo el proceso de producción de valor.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Eliminar características no necesarias.&lt;/strong&gt; Mientras más grande sea el producto más difícil será de manejar. Por lo tanto, si alguna característica no aporta valor al usuario final, necesariamente está restando valor a la compañía entera.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Algo que notar de las prácticas de DevOps es que muchas están extraídas de los movimientos de &lt;em&gt;Lean Manufacturing&lt;/em&gt;. Existen otra prácticas, pero personalmente considero que estas son las esenciales.&lt;/p&gt;

&lt;h2 id=&quot;el-segundo-camino-retroalimentación-rápida&quot;&gt;El segundo camino: Retroalimentación rápida&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1579042628/F68161CA-BF97-4E71-B78B-9310C00CD254_sjiled.jpg&quot; alt=&quot;Segundo camino de DevOps&quot; /&gt;&lt;/p&gt;

&lt;p&gt;El segundo camino por el que el valor fluye en las organizaciones que implementan DevOps es de regreso: &lt;strong&gt;debe existir un flujo de información desde los sistemas en producción&lt;/strong&gt; hacia los equipos que están desarrollando los productos y los demás equipos relacionados con esta tarea.&lt;/p&gt;

&lt;p&gt;Esto permite que los problemas sean resueltos según se van encontrando, primeramente. En segundo lugar habilita un flujo de retroalimentación rápido que permitirá crear mejores productos más rápido.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Lean Manufactruing&lt;/em&gt; recomienda que la línea de producción no debe continuar si hay algún problema con una sola de las estaciones de trabajo. Lo mismo debería pasar en los equipos de desarrollo y operaciones. Si un problema no puede ser resuelto por los encargados de ello, todo el equipo debería juntarse a resolver el problema hasta que terminen. Lo sé, esto suena contra-intuitivo y poco productivo, pero la experiencia de las fábricas japonesas demuestra que es mucho mejor resolver un problema inmediatamente en vez de dejarlo avanzar en la cadena de producción, para evitar retrabajo.&lt;/p&gt;

&lt;h2 id=&quot;el-tercer-camino-cultura-de-aprendizaje-y-experimentación&quot;&gt;El tercer camino: Cultura de aprendizaje y experimentación&lt;/h2&gt;

&lt;p&gt;Después de implementar el camino hacia el cliente y de regreso, DevOps establece que se tiene que crear un cultura de aprendizaje que permita mediante &lt;strong&gt;ciclos de retroalimentación&lt;/strong&gt; mejorar la forma general en la que se trabaja.&lt;/p&gt;

&lt;p&gt;La siguiente imagen completa los tres caminos de DevOps:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1579042629/0548901A-3BF6-49BF-8556-B0B12D45F0A9_zgljnk.jpg&quot; alt=&quot;Los tres caminos de DevOps&quot; /&gt;&lt;/p&gt;

&lt;p&gt;La empresa debe asegurarse de que los equipos de trabajo están mejorando constantemente mediante el aprendizaje continuo.&lt;/p&gt;

&lt;p&gt;Esto puede lograrse mediante varias prácticas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Experimentación, por ejemplo pruebas A/B&lt;/li&gt;
  &lt;li&gt;Introducción de fallas intencionalmente (&lt;em&gt;chaos engineering&lt;/em&gt;)&lt;/li&gt;
  &lt;li&gt;Mediciones cada vez más precisas mediante software especializado&lt;/li&gt;
  &lt;li&gt;Agendar tiempo para actividades dedicadas a mejorar el equipo como &lt;em&gt;Improvement Katas&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Este paso depende de que los dos anteriores se hayan logrado, ya que requieren de tiempo y energías, que no se tendrán si no se tiene una forma confiable de liberar el producto y de monitorear para saber que no está pasando.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Estos pilares fundamentales de DevOps nos pueden ayudar entender las bases de la cultura, pero ponerlos en práctica no es fácil. El libro &lt;a href=&quot;https://amzn.to/3a91Bgl&quot;&gt;Devops Handbook&lt;/a&gt; explica qué otra prácticas se deben seguir y da consejos prácticos que permiten lograrlo.&lt;/p&gt;

&lt;p&gt;Perfeccionar estas prácticas es algo que nunca se termina y lleva tiempo ver los resultados. Así que ¿qué esperas para empezar?&lt;/p&gt;

&lt;p&gt;Con este pequeño artículo esperamos que quede claro que &lt;a href=&quot;http://bit.ly/36t59HK&quot;&gt;DevOps no es un rol en la empresa&lt;/a&gt;.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="devops" /><category term="servers" /><category term="culture" /><summary type="html">Hablemos de qué es de DevOps y como puede beneficiar a tu empresa aplicarlo</summary></entry><entry><title type="html">Recursos gratutitos para aprender a programar desde cero</title><link href="https://blog.thedojo.mx/2019/12/29/recursos-gratutitos-para-aprender-a-programar-desde-cero.html" rel="alternate" type="text/html" title="Recursos gratutitos para aprender a programar desde cero" /><published>2019-12-29T00:00:00-06:00</published><updated>2019-12-29T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2019/12/29/recursos-gratutitos-para-aprender-a-programar-desde-cero</id><content type="html" xml:base="https://blog.thedojo.mx/2019/12/29/recursos-gratutitos-para-aprender-a-programar-desde-cero.html">&lt;p&gt;¿Quieres aprender a programar y no sabes por dónde empezar?&lt;/p&gt;

&lt;p&gt;En este post te daremos algunos recursos que puedes seguir para aprender a programar desde lo más básico hasta tener un conocimiento razonable de programación con el que podrías empezar a trabajar como becario.&lt;/p&gt;

&lt;h2 id=&quot;motívate&quot;&gt;Motívate&lt;/h2&gt;

&lt;p&gt;Para ser un buen programador es importante conocer las bases, pero para eso antes hay que tener motivación y &lt;em&gt;mantenerla&lt;/em&gt;. Así que empecemos por algo que te mostrará el poder de la programación y de lo que puedes hacer con un poco de conocimiento.&lt;/p&gt;

&lt;p&gt;Puedes empezar con la creación de una página de internet. Si buscas “Crear página web desde cero” vas a encontrar un montón de opciones, pero aquí tienes una &lt;a href=&quot;http://bit.ly/2Mq1aE0&quot;&gt;Creando una página&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;También existe el &lt;a href=&quot;http://bit.ly/34VCbyM&quot;&gt;curso para aprender programar de Platzi&lt;/a&gt;, que comienza desde los básico y con algunos ejemplos te enseña lo que se puede lograr con la programación.&lt;/p&gt;

&lt;h2 id=&quot;ahora-sí-las-bases&quot;&gt;Ahora sí, las bases&lt;/h2&gt;

&lt;p&gt;El legendario &lt;a href=&quot;http://bit.ly/39miPqa&quot;&gt;CS50&lt;/a&gt; de Harvard te ayudará a entender las bases de las ciencias de la computación, afortunadamente ya está con subtítulos en español y es completamente gratuito. Si quieres obtener un certificado puedes pagar por él en la plataforma de cursos edX. Este curso te dará bases sólidas para poder más adelante programar lo que quieras. Aprenderás varios lenguajes: Python, C++, HTML y CSS, entre otros.
Es un curso que no puedes perder si quieres ser un autodidacta de la programación.&lt;/p&gt;

&lt;p&gt;Si prefieres contenido con audio en español, este, y los que le siguen te puede ayudar: &lt;a href=&quot;http://bit.ly/2Sqj1OV&quot;&gt;Curso de introducción a Python I&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Con estos es suficiente, aunque si quieres reforzar aún más y aprender otro lenguaje te recomiendo el siguiente curso de de Uniwebsidad: &lt;a href=&quot;http://bit.ly/2PYLwSh&quot;&gt;Introducción a JavaScript&lt;/a&gt;. Este curso es bastante viejo, pero la manera de explicar del autor, la sencillez y la forma en la que avanza te hará comprender muchas cosas que te servirán para el futuro.&lt;/p&gt;

&lt;h2 id=&quot;crea-algo-real&quot;&gt;Crea algo real&lt;/h2&gt;

&lt;p&gt;Es hora de aplicar y extender el conocimiento que has adquirido hasta ahora. La mejor manera es hacer algo que tenga utilidad práctica aplicable a un problema que tú o alguien cercano vea directamente.&lt;/p&gt;

&lt;p&gt;La mejor manera de hacerlo es crear una descripción del problema que tienes, hacer una lista de las cosas que necesitas que haga y empezar a programarlo, investigando en el camino cualquier cosa que no sepas hacer. Para este punto es probable que ya seas hábil con los mejores amigos de aprendizaje del desarrollador: Google, Stack Overflow y YouTube.&lt;/p&gt;

&lt;p&gt;Si siente que aún no tienes lo suficiente aquí te dejo algunos ejemplos de cursos creando aplicaciones aunque sea pequeñas completas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://bit.ly/2Zv5Cqk&quot;&gt;Usando Flask y MySQL para hacer una aplicación&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://bit.ly/356feZM&quot;&gt;Creando aplicaciones Multi-tenant con Django&lt;/a&gt;. Este curso no es gratis pero es bastante accesible.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;has-una-especialización&quot;&gt;Has una especialización&lt;/h2&gt;

&lt;p&gt;El desarrollo de sistemas es un campo muy grande. Aunque está muy bien saber las bases y aunque sea un poco de diferentes campos (podríamos decir que es esencial), lograrás lo mejor en tu carrera si te especializas en algo:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Frontend&lt;/strong&gt; si disfrutas de las cosas visuales y tienes paciencia para luchar contra los distintos navegadores. Trabajarás con HTML, CSS y sobre todo JavaScript y sus millones de librerías.&lt;/li&gt;
  &lt;li&gt;Desarrollador de &lt;strong&gt;aplicaciones móviles&lt;/strong&gt;. Es un caso parecido al de frontend, tienes que crear las interfaces con las que los clientes van a interactuar, pero tu programa será instalado en un celular y tendrás que programarlo en Swift o Kotlin, teniendo consideraciones diferentes.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Backend&lt;/strong&gt;: si prefieres manejar datos, crear los sistemas que mantienen la información y los medios de comunicación (generalmente API’s) con clientes consumidores y productores de información. Elegir el lenguaje es difícil porque hay muchos, pero los más usados son Python, JavaScript, PHP, Java y C#.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Administrador de infraestructura&lt;/strong&gt;. Tendrás que aprender a manejar los servidores y a instalar y configurar las aplicaciones que permiten que los programas corran allí. Harás programas para automatizar varios de los pasos. Podrías programar en Bash, Go, Python, entre otros.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ingeniero de datos&lt;/strong&gt;. Aprenderás a manejar programas relacionados con la captura, tratamiento y almacenamiento de grandes cantidades de datos.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sólo mencioné algunas áreas pero hay varias más y combinaciones entre ellas.&lt;/p&gt;

&lt;p&gt;Si quieres empezar a buscar por donde te recomiendo que busques cursos en las siguientes plataformas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://bit.ly/2Q3rl5I&quot;&gt;Udacity&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://bit.ly/354mUff&quot;&gt;Coursera&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://bit.ly/2Zw09j0&quot;&gt;edX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Estas tres plataformas tienen cursos gratuitos en español (por lo menos subtitulados) casi sobre cualquier cosa que quieras aprender, incluído los mencionados. No te olvides de YouTube.&lt;/p&gt;

&lt;h3 id=&quot;aprende-inglés&quot;&gt;Aprende inglés&lt;/h3&gt;

&lt;p&gt;Si tu deseo es poder programar o desarrollar software profesionalmente, una de las cosas que tienes que hacer sí o sí es por lo menos aprender a &lt;strong&gt;leer inglés&lt;/strong&gt;. Esto te ayudará a cubrir el 83.5% (número inventado) de las situaciones para aprender más. Muy probablemente si sabes leer en inglés sabrás escribirlo a un grado razonable para &lt;strong&gt;programar en inglés&lt;/strong&gt;, es decir, crear los comentarios, los nombres y otros textos requeridos en inglés, ya que hará tu código de más fácil acceso a un mayor número de personas.&lt;/p&gt;

&lt;p&gt;Una vez dominado esto se te abre la puerta al 80% de recursos de aprendizaje de internet. Y las posibilidades son ilimitadas.&lt;/p&gt;

&lt;h3 id=&quot;obliga-a-alguien-a-ser-tu-mentor&quot;&gt;Obliga a alguien a ser tu mentor&lt;/h3&gt;

&lt;p&gt;Esto suena un poco raro, pero claro que lo puedes hacer y es de las maneras más eficaces de aprender. Lo mejor de todo es que no necesitas ni siquiera que tue mentor esté vivo. Hacer a alguien tu mentor significa aprender de él y muchas personas nos han preparado el camino para que los tomemos como mentores: mediante sus libros. Busca ejemplos de personas como las que quisieras ser e inspírate en sus escritos, charlas, conferencias, entrevistas, podcasts y todo contenido que produzca para ver como puedes recorrer un camino parecido al de esa persona.&lt;/p&gt;

&lt;h2 id=&quot;notas-finales&quot;&gt;Notas finales&lt;/h2&gt;

&lt;p&gt;Lo que acabas de aprender después de terminar esto son sólo las bases. Igual que muchas otras carreras, en ésta tienes que poder seguir aprendiendo constantemente. El desarrollo de software, sin embargo, se caracteriza por ciclos más cortos aún, en los que las habilidades se quedan obsoletas en mucho menos tiempo así que debes afinar tus habilidades de aprendizaje.&lt;/p&gt;

&lt;p&gt;Una de las mejores maneras de solidificar tu conocimiento después de practicarlo, es enseñándolo a otros. No te quedes con lo aprendiste y devuelve algo a la comunidad: enseña siempre que puedas mediante conferencias, videos o artículos en un blog. De esto es algo de lo que no te arrepentirás.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="aprender" /><category term="programar" /><category term="recursos-aprendizaje" /><summary type="html">Hemos escrito una lista de recursos que te pueden ayudar a aprender a programar en tiempo record.</summary></entry><entry><title type="html">Las matemáticas que debes saber para programar</title><link href="https://blog.thedojo.mx/2019/12/25/las-matematicas-que-debes-saber-para-programar.html" rel="alternate" type="text/html" title="Las matemáticas que debes saber para programar" /><published>2019-12-25T00:00:00-06:00</published><updated>2019-12-25T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2019/12/25/las-matematicas-que-debes-saber-para-programar</id><content type="html" xml:base="https://blog.thedojo.mx/2019/12/25/las-matematicas-que-debes-saber-para-programar.html">&lt;p&gt;Cuando se habla de &lt;strong&gt;matemáticas&lt;/strong&gt; mucha gente empieza a sentirse fastidiada porque creen que son cosas difíciles de entender.&lt;/p&gt;

&lt;p&gt;Sin embargo, las matemáticas son la base de muchas otras ciencias y sobre de todo de la computación. Podríamos considerar las ciencias de la computación como &lt;strong&gt;una rama de las matemáticas&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Pero para programar con eficacia no necesitas saber muchas matemáticas, de hecho, con el entendimiento básico es suficiente. En este artículo hablaremos de aquello que debes dominar.&lt;/p&gt;

&lt;h2 id=&quot;qué-son-las-matemáticas&quot;&gt;¿Qué son las matemáticas?&lt;/h2&gt;

&lt;p&gt;Definir las matemáticas es difícil. Según lo que (de manera muy irresponsable) nos han enseñado en la escuela, las matemáticas es el tratamiento de los &lt;strong&gt;números&lt;/strong&gt;. Eso está muy lejos de la realidad, y ya te habás dado cuenta si has avanzado lo suficiente en matemáticas.&lt;/p&gt;

&lt;p&gt;Es cierto, las matemáticas más elementales se pueden reducir a números, pero no es su centro, el espíritu de su estudio.&lt;/p&gt;

&lt;p&gt;Algunas definiciones que encontré útiles:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Las matemáticas son la manera que tenemos de elevar a la categoría de un arte nuestros &lt;strong&gt;esfuerzos cognoscitivos&lt;/strong&gt;. - Fausto Ongay&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ongay también menciona que la etimología de la palabra matemáticas tiene que ver con conocer o saber. Así, en cierta medida las matemáticas se pueden pensar como la ciencia o el arte &lt;strong&gt;de la certidumbre&lt;/strong&gt;. Es decir, de saber algo con certeza y poder verificarlo.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;La matemática, como una expresión de la mente humana, refleja la voluntad activa, la razón contemplativa, y el deseo de la perfección. Sus elementos básicos son: lógica e intuición, análisis y construcción, generalidad y particularidad. - Richard Courant&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;En esta definición un poco más poética y abstracta se mencionan los elementos usados para lograr su cometido: lógica, intuición, análisis, construcción (o síntesis), generalidad (inducción), particularidad (deducción). Ya hablamos un poco de esto en los artículos acerca de las idea de &lt;a href=&quot;http://bit.ly/39madQm&quot;&gt;George Polya&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Si quieres adentrarte en esto el libro &lt;a href=&quot;http://bit.ly/2F4Dn8N&quot;&gt;&lt;strong&gt;¿Qué son las matemáticas?&lt;/strong&gt;&lt;/a&gt; habla de ello a fondo.&lt;/p&gt;

&lt;p&gt;Pero no estamos aquí para filosofar acerca de las matemáticas. Lo único que quiero quede claro con esto es que las matemáticas no tienen que ver con &lt;strong&gt;números&lt;/strong&gt;, sino con el &lt;em&gt;razonamiento&lt;/em&gt;, &lt;em&gt;certidumbre&lt;/em&gt; y resolución de problemas.&lt;/p&gt;

&lt;h2 id=&quot;matemáticas-básicas&quot;&gt;Matemáticas Básicas&lt;/h2&gt;

&lt;p&gt;Empecemos hablando brevemente de las matemáticas que debes conocer como programador y como ser humano.&lt;/p&gt;

&lt;h3 id=&quot;operaciones-básicas&quot;&gt;Operaciones básicas&lt;/h3&gt;

&lt;p&gt;Saber operar con números en la vida cotidiana es una habilidad que todos necesitamos. Pero más importante aún es entender el significado de estas operaciones:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¿Qué significa una multiplicación?&lt;/li&gt;
  &lt;li&gt;¿Qué significa una división?&lt;/li&gt;
  &lt;li&gt;¿Qué significado tiene el elevar un número a una potencia?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Entender esto te ayudará a &lt;strong&gt;resolver problemas&lt;/strong&gt; que es la actividad principal que se realiza cuando programas. Todo lo demás está alrededor de esto.&lt;/p&gt;

&lt;h3 id=&quot;probabilidad-y-estadística&quot;&gt;Probabilidad y estadística&lt;/h3&gt;

&lt;p&gt;Tener las nociones de estas áreas es una de las herramientas más útiles a la hora de resolver problemas y sobre todo atacarlos prácticamente. Varias de las áreas de la ciencia de la computación basan sus resultados y procesos en estas dos áreas.&lt;/p&gt;

&lt;p&gt;Un ejemplo es la &lt;strong&gt;criptografía&lt;/strong&gt;: los algoritmos de cifrado como &lt;strong&gt;AES&lt;/strong&gt; trabajan con una llave que es usada para cifrar y descifrar el mensaje. Asignar el tamaño de la llave depende totalmente de la &lt;em&gt;probabilidad&lt;/em&gt; de que un atacante sea capaz de adivinar la llave en un número de intentos razonable.&lt;/p&gt;

&lt;p&gt;Ahora imagina que la llave tiene 128 bits de longitud. Aquí entra otro par de conceptos importantes para la computación.&lt;/p&gt;

&lt;h3 id=&quot;combinaciones-y-permutaciones&quot;&gt;Combinaciones y permutaciones&lt;/h3&gt;

&lt;p&gt;¿Cuál es el número de llaves diferentes que se pueden generar con 128 bits? La respuesta es: 2^128 (2 elevado a la potencia 128). &lt;em&gt;¿Cómo llegamos a esa respuesta?&lt;/em&gt; Esto se conoce como &lt;strong&gt;conteo&lt;/strong&gt; en matemáticas y las bases son la &lt;strong&gt;permutación&lt;/strong&gt; y la &lt;strong&gt;combinación&lt;/strong&gt; de elementos. En este caso es la permutación de 2 elementos que permiten repetición en 128 lugares.&lt;/p&gt;

&lt;p&gt;¿Qué probabilidad hay de que alguien encuentre esa llave por suerte en el primer intento?&lt;/p&gt;

&lt;p&gt;La respuesta es 1/2^128. Tan cerca de cero para ser considerada prácticamente imposible de adivinar incluso en un número de intentos razonable.&lt;/p&gt;

&lt;p&gt;La criptografía y varias áreas están llenas de probabilidad y estadística (como el aprendizaje automático y el análisis de datos, aunque más avanzadas).&lt;/p&gt;

&lt;p&gt;Si sientes que necesitas un recordatorio aquí hay un curso que enseña desde lo más básico: &lt;a href=&quot;http://bit.ly/2rrL4mb&quot;&gt;Conteo, combinaciones y permutaciones en Khan Academy&lt;/a&gt;. Este también es un curso que enseña probabilidad y estadística desde cero.&lt;/p&gt;

&lt;h2 id=&quot;lógica-matemáticas-discretas&quot;&gt;Lógica (Matemáticas discretas)&lt;/h2&gt;

&lt;p&gt;Las matemáticas discretas son una de las áreas más abstractas de las matemáticas cuando las vemos en papel pero en realidad tratamos con ellas a diario. Podemos definir las matemáticas discretas como el estudio de las cosas que se pueden contar, sean finitas o infinitas.&lt;/p&gt;

&lt;p&gt;La &lt;strong&gt;lógica&lt;/strong&gt; es uno de los campos de estudio de las matemáticas discretas. La lógica se enfoca en estudiar &lt;strong&gt;el razonamiento&lt;/strong&gt; y sobre todo si el razonamiento es &lt;em&gt;correcto&lt;/em&gt;.
Para lograr esto la lógica se vale del estudio de las &lt;strong&gt;proposiciones&lt;/strong&gt; (o afirmaciones) y sus relaciones. Una proposición es un enunciado que dice algo que puede ser &lt;em&gt;verdadero&lt;/em&gt; o &lt;em&gt;falso&lt;/em&gt;. En matemáticas se dice que tiene un &lt;strong&gt;valor de verdad&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Dos proposiciones se pueden relacionar mediante un &lt;em&gt;conector&lt;/em&gt; (en electrónica: compuertas lógicas, en programación son operadores booleanos). Los conectores más conocidos son el &lt;strong&gt;or&lt;/strong&gt; (o) y el &lt;strong&gt;and&lt;/strong&gt;(y).&lt;/p&gt;

&lt;p&gt;Esto da origen a demostraciones tanto matemáticas como prácticas. En el desarrollo de sistemas se pueden usar para demostrar que tu algoritmo o solución es correcto, es decir, va a funcionar con los datos de entrada propuestos que cumplan con los valores de verdad.&lt;/p&gt;

&lt;p&gt;¿Son absolutamente necesarias para programar? Las demostraciones no, pero serán útiles si quieres crear demostraciones de que un algoritmo funciona sin tener que crear miles de ejemplos que convenzan a alguien. &lt;strong&gt;Lo que sí es necesario entender es el funcionamiento de los conectores lógicos, no hay programa que se escape de ellos.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;conjuntos&quot;&gt;Conjuntos&lt;/h3&gt;

&lt;p&gt;El estudio de los conjuntos es una parte de las matemáticas discretas que se enfoca en estudiar elementos (objetos) que se agrupan por alguna característica en común. Los conjuntos son de gran utilidad para resolver muchos problemas matemáticos y la criptografía actual esta fuertemente basada en algunos problemas que tienen que ver con el cálculo de ciertos conjuntos.&lt;/p&gt;

&lt;p&gt;¿Me sirve para trabajar en el día a día? Para cierto tipo de problemas es más cómodo trabajar con conjuntos que con los tipos de datos comunes de colecciones a los que estamos acostumbrados los programadores. Tratar tu colección (lista, tupla, etc.) como un conjunto matemático te permitirá efectuar operaciones como la &lt;strong&gt;intersección de conjuntos&lt;/strong&gt; (elementos en común), la &lt;strong&gt;unión&lt;/strong&gt; (todos los elementos únicos encontrados en dos o más conjuntos). Si el lenguaje de programación tiene este tipo de dato te va a dar un buen empujón.&lt;/p&gt;

&lt;p&gt;Por cierto, el resultado de las consultas en SQL (lenguaje de manejo de datos para la mayoría de las bases de datos) se comportan como conjuntos matemáticos.&lt;/p&gt;

&lt;p&gt;¿Quieres aprender matemáticas discretas? Aquí tienes un pequeño curso: &lt;a href=&quot;http://bit.ly/2EWToND&quot;&gt;Curso de matemáticas discretas&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Eso es todo lo que necesitas para programar básicamente. Mientras mejor seas en estos campos, mejor podrás aprovecharlos para programar mejor o para entender mejor los programas de otros.&lt;/p&gt;

&lt;h3 id=&quot;sistemas-numéricos&quot;&gt;Sistemas numéricos&lt;/h3&gt;

&lt;p&gt;Los sistemas numéricos son un tipo de conjuntos que se conforman de todas las cifras que pueden formarse con una cantidad determinada de símbolos que representan los números. El número de símbolos le da nombre al sistema: si hay dos símbolos (0, 1) es binario, si hay tres (0, 1, 2), ternario, etc.&lt;/p&gt;

&lt;p&gt;Para programar es muy conveniente que entiendas básicamente cómo se define un sistema numérico y que conozcas por lo menos cuatro:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Decimal&lt;/strong&gt;. Incluye los símbolos que conocemos como dígitos (0, 1, 2,.., 9). Su base es el 10.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Binario&lt;/strong&gt;. Es el sistema numérico con el que los microprocesadores pueden trabajar. Por eso es importante conocerlos. Sólo se pueden usar dos valores: 0 y 1.  Su base es el 2.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Hexadecimal&lt;/strong&gt;. Se usa por conveniencia para representar números binarios de manera abreviada, por su compatibilidad entre bases (16 = 2^4). Su base es el 16 y los símbolos o valores extra que incluye a parte de los dígitos comunes son las letras de la A a la F.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Octal&lt;/strong&gt;. Su base es el 8 y también se usa para abreviar números decimales. Usa los dígitos del 0 al 7.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;El sistema decimal lo usamos en la vida diaria. Con entender básicamente el binario y hexadecimal estarás bien.&lt;/p&gt;

&lt;h1 id=&quot;matemáticas-avanzadas-y-especificas&quot;&gt;Matemáticas avanzadas y especificas&lt;/h1&gt;

&lt;p&gt;En muchas áreas de la programación se usan matemáticas más avanzadas, sobre todo en áreas que están sonando mucho recientemente: análisis de datos e inteligencia artificial. Si quieres entender a fondo estas y otras áreas del desarrollo de sistemas, es conveniente tener un conocimiento amplio en algunas de las siguientes áreas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Probabilidad y estadística avanzada&lt;/strong&gt;. Saber acerca de variables aleaterias, distribuciones de probabilidad, análisis Bayesiano, etc. Esto te permitirá analizar datos tanto exploratoria como predictivamente.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Álgebra lineal&lt;/strong&gt;. El álgebra y la resolución de ecuaciones que representan líneas en el plano cartesiano. Esto te ayudará a tratar con conjuntos de datos. Muchas de los resultados de los algoritmos de Machine Learning son ecuaciones lineales.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ecuaciones diferenciales&lt;/strong&gt;. Esto es la resolución de sistemas de ecuaciones y sus derivadas. Esto tiene aplicaciones en todo lo que tenga que ver con cambios respecto a alguna variable, como el tiempo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hablé de los campos finales pero para entender esto debes saber antes cosas como:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Geometría Analítica&lt;/li&gt;
  &lt;li&gt;Álgebra&lt;/li&gt;
  &lt;li&gt;Trigonometría&lt;/li&gt;
  &lt;li&gt;Cálculo Integral y diferencial&lt;/li&gt;
  &lt;li&gt;Cálculo Vectorial&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por suerte, para los campos de los que hablá arriba no tienes que saber todo esto, a menos que quieras ser el desarrollador de los algoritmos originales. Generalmente somos usuarios de bibliotecas creadas por genios que ya hacen lo que necesitamos.&lt;/p&gt;

&lt;h2 id=&quot;no-te-preocupes-&quot;&gt;No te preocupes :)&lt;/h2&gt;

&lt;p&gt;Fuera de las matemáticas básicas y un control decente e intuitivo de la lógica, no es necesario que seas &lt;a href=&quot;http://bit.ly/2StKLCz&quot;&gt;Terence Tao&lt;/a&gt;, a menos que el campo en el que estés trabajando esté directamente relacionado con eso, tal
como tendrías que saber lo suficiente de finanzas si estuvieras haciendo una app financiera o de administración de empresas si estuvieras haciendo una aplicación o plataforma para este campo.&lt;/p&gt;

&lt;p&gt;Aquí hay un video curso en el que se explican más ampliamente lo que algunos llaman &lt;a href=&quot;http://bit.ly/2rvD6Zi&quot;&gt;“matemáticas para programadores”&lt;/a&gt;.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="math," /><category term="matemáticas," /><category term="aprender" /><summary type="html">¿Qué tantas matemáticas necesitas para programar? En este artículo lo veremos.</summary></entry><entry><title type="html">Formatos de marcado de texto que deberías aprender</title><link href="https://blog.thedojo.mx/2019/12/20/formatos-de-marcado-de-texto-que-deberias-aprender.html" rel="alternate" type="text/html" title="Formatos de marcado de texto que deberías aprender" /><published>2019-12-20T00:00:00-06:00</published><updated>2019-12-20T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2019/12/20/formatos-de-marcado-de-texto-que-deberias-aprender</id><content type="html" xml:base="https://blog.thedojo.mx/2019/12/20/formatos-de-marcado-de-texto-que-deberias-aprender.html">&lt;p&gt;Parte del trabajo de un desarrollador es crear documentos con un formato fácil de entender y agradable a la vista, para crear documentación, registrar decisiones, escribir manuales, etc. La forma común de hacerlos es un procesador de textos como Word o Google Docs, pero generalmente batallamos sobre todo con el formateo y embellecimiento de documento.&lt;/p&gt;

&lt;p&gt;En este artículo te platicaré de &lt;strong&gt;tres alternativas&lt;/strong&gt; que pueden hacer tu vida más fácil: Markdown, reStructuredText, AsciiDoc.&lt;/p&gt;

&lt;p&gt;Todos estos lenguajes pueden producir múltiples formatos de salida: HTML, PDF, Word, entre otros. Y lo mejor es que estas salidas son personalizables.&lt;/p&gt;

&lt;h2 id=&quot;markdown&quot;&gt;Markdown&lt;/h2&gt;

&lt;p&gt;Es el formato de marcado de texto simple más conocido por ser el usado en muchos lados (GitHub, por ejemplo) para darle un poco de formato semántico al texto.&lt;/p&gt;

&lt;p&gt;Puedes crear los estilos de texto más comunes directamente:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;negritas&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;cursivas&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/&quot;&gt;enlaces&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Imágenes:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_100/v1559453194/luis-dille-1098834-unsplash_vndt6g.jpg&quot; alt=&quot;Imagen de ejemplo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;También permite crear listas no numeradas, como la anterior, numeradas, tablas (con las sintaxis extendidas pero no con la definición original) y una serie de títulos de diferente jerarquía equivalentes a los headers de HTML (h1, h2… h6).&lt;/p&gt;

&lt;p&gt;De hecho, esta entrada está escrita con Markdown. Markdown es tan popular que existen aplicaciones completamente dedicadas a él como &lt;a href=&quot;http://bit.ly/2M7YmLL&quot;&gt;MacDown&lt;/a&gt;, &lt;a href=&quot;http://bit.ly/38Zhohc&quot;&gt;Focused&lt;/a&gt; y &lt;a href=&quot;http://bit.ly/2S4MX38&quot;&gt;Typora&lt;/a&gt;. Además, diferentes empresas han creado sus propios dialectos o adaptaciones para que sea más fácil de usar en su caso específico.&lt;/p&gt;

&lt;p&gt;Si aún no lo sabes usar, vale la pena que le eches un ojo: &lt;a href=&quot;http://bit.ly/38S2l8G&quot;&gt;Guía de Markdown en español&lt;/a&gt;. Tardarás unos minutos en aprender lo básico que es muy útil para el 80% de los casos en los que lo ocuparas.&lt;/p&gt;

&lt;p&gt;Markdown es muy bueno para crear documentos individuales pero, ¿qué pasa si el texto que quieres escribir es más extenso? Tal vez el texto está compuesto por muchas partes, como un libro o una documentación extensa. Hay quienes dicen que &lt;a href=&quot;http://bit.ly/2sOpmJg&quot;&gt;no deberías usar Markdown para crear tu documentación&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Las siguientes herramientas están mejor que preparadas que Markdown para eso, permiten crear cuerpos de textos más extensos.&lt;/p&gt;

&lt;h2 id=&quot;restructuredtext&quot;&gt;reStructuredText&lt;/h2&gt;

&lt;p&gt;Este formato de texto es adecuado para crear cuerpos de texto más complejos que con Markdown. Tienes las mismas capacidades de formateo de texto que con Markdown: negritas, cursivas, cabeceras, links, imágenes, listas, tablas, etc.&lt;/p&gt;

&lt;p&gt;Pero reStructuredText provee &lt;strong&gt;más opciones&lt;/strong&gt; para formatear el texto, ya que fue creado para hacer &lt;em&gt;documentos técnicos&lt;/em&gt; además de documentos de carácter general.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;reStructuredText&lt;/strong&gt; parece ser parte de &lt;a href=&quot;http://bit.ly/2ECmEt2&quot;&gt;docutils&lt;/a&gt; originalmente, creado como una revisión de se &lt;a href=&quot;http://bit.ly/35NkdQk&quot;&gt;StructuredText&lt;/a&gt; y &lt;a href=&quot;http://bit.ly/2PIAdgT&quot;&gt;Setext&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Sus herramientas te permitirán crear texto marcado con &lt;strong&gt;mejor semántica&lt;/strong&gt; que Markdown, más estandarizado (RST no tiene ‘sabores’ o dialectos) y con herramientas adaptadas a la documentación de código. Entre otras cosas RST provee:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Más formatos de listas:
    &lt;ul&gt;
      &lt;li&gt;Listas de definición&lt;/li&gt;
      &lt;li&gt;Listas de parámetros&lt;/li&gt;
      &lt;li&gt;Numeración de listas arbitrariamente&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bloques de texto pre-formateado (para código)&lt;/li&gt;
  &lt;li&gt;Bloques de documentación de pruebas&lt;/li&gt;
  &lt;li&gt;Citas&lt;/li&gt;
  &lt;li&gt;Notas a pie de página&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Directivas&lt;/strong&gt;, una manera de extender el lenguaje con construcciones propias&lt;/li&gt;
  &lt;li&gt;Hyperlinks con diferentes destinos: externos, internos, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Esta última característica permite crear documentos interconectados que son muy útiles para textos amplios.&lt;/p&gt;

&lt;p&gt;RST es el formato default de &lt;a href=&quot;http://bit.ly/35Jb6QP&quot;&gt;Sphinx&lt;/a&gt; una herramienta de documentación de código creada en Python que te puede ayudar a crear documentación muy bonita.&lt;/p&gt;

&lt;p&gt;Aquí hay una introducción a RST en inglés: &lt;a href=&quot;http://bit.ly/2rdQn8y&quot;&gt;A reStructuredText Primer&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;asciidoc&quot;&gt;AsciiDoc&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Incluso el software más brillante es inútil sin buena documentación. - Documentación de AsciiDoc&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;AsciiDoc&lt;/strong&gt; fue creado para hacer &lt;strong&gt;tan fácil como escribir un email&lt;/strong&gt; la escritura de cualquier tipo de documento, sea este un artículo, un texto en prosa, un libro o documentación técnica.&lt;/p&gt;

&lt;p&gt;El creador asegura que una de las causas de que se nos haga tan difícil escribir está relacionada con que los editores de texto nos distraen con cosas como el formateo o paja que no es necesaria. AsciiDoc se enfoca en que puedas escribir sin preocuparte por el formato, dando una sintaxis natural, fluída y que no estorba, mientras te permite preparar el texto para crear formatos de salida hermosos.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Usa AsciiDoc para marcado de documentos. De verdad. En verdad es legible, fácil de procesar y mucho más flexible que XML. - Linus Torvalds&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Al igual que Markdown y RST, AsciiDoc provee de medios básicos para dar formato al texto. Pero AsciiDoc es el que más herramientas de los tres platicados aquí tiene. Además de ofrecet todo lo de las dos herrmientas anteriores tiene:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Más formatos de párrafo: párrafos de introducción y pre-formateados fáciles.&lt;/li&gt;
  &lt;li&gt;Secciones prediseñadas: cuadros de aviso, de notas, etc.&lt;/li&gt;
  &lt;li&gt;Estilos de lista parecidos a los de RST.&lt;/li&gt;
  &lt;li&gt;Formateo y sintaxis de código con notas, como la siguiente:
&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_700/v1576905208/Screenshot_2019-12-20_23.12.38_mdhrfj.png&quot; alt=&quot;Ejemplo de notas&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Barras laterales&lt;/li&gt;
  &lt;li&gt;Macros&lt;/li&gt;
  &lt;li&gt;Generación de tablas desde CSV&lt;/li&gt;
  &lt;li&gt;Videos&lt;/li&gt;
  &lt;li&gt;Muchas muchas cosas más…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sin duda AsciiDoc es el más completo de los formatos que hemos visto en este artículo. Aquí hay una &lt;a href=&quot;http://bit.ly/2PKzdZN&quot;&gt;introducción en inglés&lt;/a&gt; y aquí un &lt;a href=&quot;http://bit.ly/2rgL3Bt&quot;&gt;libro en español&lt;/a&gt;. AsciiDoc es tan completo que varios autores de libros lo han escogido para crear sus escritos.&lt;/p&gt;

&lt;h2 id=&quot;cuál-uso-entonces&quot;&gt;¿Cuál uso, entonces?&lt;/h2&gt;

&lt;p&gt;Mi conclusión personal es la siguiente:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Si tienes que hacer un documento pequeño, sin mucho formato y en el que la velocidad de entrega es lo más importante usa Markdown, ya que su popularidad te permitirá entregar el documento en el menor tiempo posible. Por ejemplo, en GitHub subes un archivo “*.md” y automáticamente lo muestra formateado.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;¿Tienes que hacer documentación de código que posiblemente deba ir en línea o al lado del código? reStructuredText está especializado en eso y con sus herramientas y entonrno te facilitará la vida.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Para todo lo demás, usa &lt;strong&gt;AsciiDoc&lt;/strong&gt;. Una vez que lo sabes usar y combinado con AsciiDoctor (su procesador) y &lt;a href=&quot;http://bit.ly/2Q2zbeE&quot;&gt;Pandoc&lt;/a&gt; (un transformador de formatos) puedes crear cosas muy complejas muy rápidamente.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Si eres como los programadores clásicos, odias usar Word, Docs o lo que sea por el problema que es formatear mientras escribes y amas la simplicidad del texto plano ayudado con herramientas que te permiten crear mejores cosas.&lt;/p&gt;

&lt;p&gt;Estos lenguajes de marcado de texto te dan lo mejor de los dos mundos. Requieren un poco más de trabajo para empezar que los editores &lt;em&gt;“lo que ves es lo que obtienes”&lt;/em&gt;, pero la productividad que te dan después paga con creces.&lt;/p&gt;

&lt;p&gt;¿Qué opinas? ¿Vale la pena aprenderlos?&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="markdown" /><category term="restructured-text" /><category term="asciidoc" /><category term="latex" /><summary type="html">A veces tienes que crear documentos de texto con un algún tipo de formato visual. Aprende lenguajes de marcado que te facilitarán la vida.</summary></entry><entry><title type="html">Inducción y Deducción según Polya</title><link href="https://blog.thedojo.mx/2019/12/14/induccion-y-deduccion-segun-polya.html" rel="alternate" type="text/html" title="Inducción y Deducción según Polya" /><published>2019-12-14T00:00:00-06:00</published><updated>2019-12-14T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2019/12/14/induccion-y-deduccion-segun-polya</id><content type="html" xml:base="https://blog.thedojo.mx/2019/12/14/induccion-y-deduccion-segun-polya.html">&lt;p&gt;Este es el tercer artículo acerca del libro &lt;a href=&quot;https://amzn.to/2P8HJA8&quot;&gt;“How to Solve It”&lt;/a&gt; de George Polya. Puedes ver los dos artículos anteriores aquí:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2019/09/27/tecnicas-para-resolver-problemas.html&quot;&gt;Técnicas para resolver problemas&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2019/10/03/el-arte-de-resolver-problemas-la-heuristica.html&quot;&gt;Heurística&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Con este artículo cerraremos con las ideas que George Polya desarrolló para resolver problemas.&lt;/p&gt;

&lt;h2 id=&quot;inducción-y-deducción&quot;&gt;Inducción y Deducción&lt;/h2&gt;

&lt;p&gt;Hablemos ahora de algunas formas de resolver problemas.&lt;/p&gt;

&lt;h3 id=&quot;deducción&quot;&gt;Deducción&lt;/h3&gt;

&lt;p&gt;Tratar de resolver problemas por deducción significa &lt;strong&gt;aplicar principios o
conocimiento general a un caso específico&lt;/strong&gt;. Por ejemplo para un problema
práctico en el que tenemos encontrar la longitud de un cable tensor para una
antena, sabemos que podemos aplicar el teorema de Pitágoras.&lt;/p&gt;

&lt;p&gt;Algunos ejemplos para los programadores:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Encontrar el elemento más grande o más pequeño en una lista. (Una forma de resolverlo es ordenar los elementos).&lt;/li&gt;
  &lt;li&gt;Revisar que un elemento no está repetido en una colección de elementos. (Indexado)&lt;/li&gt;
  &lt;li&gt;Asegurarse de que las operaciones son atendidas en el orden en que se solicitaron en un entorno con múltiples ejecutores. (Colas)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lo difícil de la deducción es encontrar &lt;em&gt;qué principios, teoremas o formas 
de resolución de problemas aplican para el problema que tenemos que resolver&lt;/em&gt;. Para esto nos pueden ayudar las técnicas platicadas en los artículos anteriores: ¿He resuelto un problema similar? &lt;em&gt;¿Qué técnica fue usada?&lt;/em&gt; ¿Qué principios sirvieron para la resolución de ese problema? Y, a mi parecer la más útil: ¿puedo usar el resultado o el proceso de resolución?&lt;/p&gt;

&lt;!-- Polya dice que aunque se dice que Sherlock Holmes &quot;deduce&quot;, en realidad aplica la inducción para llegar a conclusiones, ya que aplica conocimiento general a casos concretos. --&gt;

&lt;h3 id=&quot;inducción&quot;&gt;Inducción&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;La inducción es el proceso de descubrir leyes generales mediante la observación y combinación de casos particulares. - &lt;em&gt;George Polya&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;La inducción es uno de los mecanismos de resolución de problemas más difíciles de llevar a la práctica. Funciona en forma inversa a la deducción.&lt;/p&gt;

&lt;p&gt;Consiste en partir de observaciones específicas (ejemplos y contra-ejemplos) y llevarlas a &lt;strong&gt;generalizaciones&lt;/strong&gt; que puedan ser aplicadas en otros casos o que apliquen en muchas otras situaciones situaciones.&lt;/p&gt;

&lt;h3 id=&quot;en-el-desarrollo-de-software&quot;&gt;En el desarrollo de software&lt;/h3&gt;

&lt;p&gt;Seguro te has encontrado con este tipo problemas (o te vas a encontrar) si ya llevas tiempo desarrollando: ya que el desarrollo de software no es un área que viva aislada de las demás áreas, los que requieren el software llevan &lt;em&gt;ejemplos&lt;/em&gt; de  problemas que regularmente tienen que resolver. Nuestros clientes, en general, no se han dado a la tarea de establecer las reglas por las que algo funciona de la manera en que lo hace, ni las excepciones ni los casos únicos. Es nuestra tarea casi siempre descubrir las reglas que subyacen a las operaciones comunes. Esto es una forma de inducción.&lt;/p&gt;

&lt;h3 id=&quot;inducción-matemática&quot;&gt;Inducción matemática&lt;/h3&gt;

&lt;p&gt;Polya habla de otro tipo de inducción de la que opina que no debería llamarse así, y que comparte muy poco con el proceso que acabamos de descubrir y puede llegar a confundir a la gente: la &lt;strong&gt;inducción matemática&lt;/strong&gt;. Este tipo de inducción se refiere al método que los matemáticos emplean para demostrar que cierta aserción es un teorema o no.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="polya" /><category term="problem-solving" /><category term="how-to-solve-it" /><summary type="html">Aprende de los conceptos de inducción y deducción según George Polya los explica en How to Solve It</summary></entry><entry><title type="html">Criptografía básica para programadores: ¿Qué es la criptografía?</title><link href="https://blog.thedojo.mx/2019/11/12/criptografia-basica-para-programadores-que-es-la-criptografia.html" rel="alternate" type="text/html" title="Criptografía básica para programadores: ¿Qué es la criptografía?" /><published>2019-11-12T00:00:00-06:00</published><updated>2019-11-12T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2019/11/12/criptografia-basica-para-programadores-que-es-la-criptografia</id><content type="html" xml:base="https://blog.thedojo.mx/2019/11/12/criptografia-basica-para-programadores-que-es-la-criptografia.html">&lt;p&gt;Es muy común escuchar de “encriptación” (la palabra correcta en español es &lt;em&gt;cifrado&lt;/em&gt;), llaves, algoritmos criptográficos y cosas parecidas, sobre todo con el surgimiento de Bitcoin y Blockchain.&lt;/p&gt;

&lt;p&gt;Uno de los temas menos tratados por programadores de software común (para usuarios y sistemas que no impliquen el uso de seguridad a medida), es el correcto uso de los algoritmos criptográficos y muchas veces ni siquiera conocemos lo suficiente de ellos, sino que confiamos en lo que las herramientas pre-establecen (que gran parte de las veces fue diseñado por expertos y eso está bien).&lt;/p&gt;

&lt;p&gt;Pero un poco de conocimiento sobre criptografía no te hará daño, sobre todo si programas sistemas que necesiten seguridad (todos), y sí puede evitarte errores fatales.&lt;/p&gt;

&lt;p&gt;Esta serie de artículos tratará de todo lo que un programador debe saber acerca de la aplicación correcta de algoritmos criptográficos a sus desarrollos, y un poco de su funcionamiento interno.&lt;/p&gt;

&lt;p&gt;Empecemos por lo más básico. ¿Qué es exactamente la criptografía?&lt;/p&gt;

&lt;h2 id=&quot;definición-de-criptografía&quot;&gt;Definición de Criptografía&lt;/h2&gt;

&lt;p&gt;La criptografía moderna se puede considerar una rama de las matemáticas (&lt;em&gt;otra vez&lt;/em&gt;) y la computación enfocada en encontrar y crear formas de convertir información clara y con algún significado en &lt;em&gt;información imposible de entender por entidades que no cuenten con la autorización para hacerlo, aunque la tengan en su poder&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;La palabra quiere decir literalmente &lt;strong&gt;“escritura oculta”&lt;/strong&gt;. Y también se puede definir el campo como el encargado de encontrar algoritmos o procedimientos que permitan ocultar mensajes que sólo puedan ser descifrados por aquellos que tengan la llave.&lt;/p&gt;

&lt;p&gt;La criptografía implica &lt;em&gt;esconder&lt;/em&gt; información explícitamente (los atacantes pueden saber que esa información está oculta e incluso hasta tener los mensajes ocultos en su poder), de manera que quien tenga la información correcta (que les concede la autorización) pueda obtener la información original desde los datos ininteligibles.&lt;/p&gt;

&lt;p&gt;Este proceso de ocultar la información se llama &lt;strong&gt;cifrado&lt;/strong&gt; (también se usa &lt;em&gt;encriptado&lt;/em&gt;, como un barbarismo), mientras que el proceso de recuperar la información se llama &lt;strong&gt;descifrado&lt;/strong&gt; (o &lt;em&gt;desencriptado&lt;/em&gt; 🙄).&lt;/p&gt;

&lt;p&gt;Los procesos de cifrado modernos requieren generalmente &lt;strong&gt;una llave o conjunto de llaves&lt;/strong&gt;, para realizar los procesos de cifrado y descifrado.&lt;/p&gt;

&lt;p&gt;La criptografía es la base de todos los mecanismos de seguridad informática modernos, y a menudo se usa una conbinación de ellos para proteger un sistema.&lt;/p&gt;

&lt;h2 id=&quot;uso-en-el-software-actual&quot;&gt;Uso en el software actual&lt;/h2&gt;

&lt;p&gt;Los algoritmos criptográficos se usan en todos lados en los sistemas modernos. Son los algoritmos que permiten que la información viaje segura en internet (usando HTTPS, que se basa en TLS/SSL), por ejemplo. Algunos otros casos en los que son usados:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;En la protección de la información que viaja en las redes inalámbricas, sean WiFi o Celulares (3G, 4G, 5G).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Almacenamiento de datos sensibles como passwords (mediante hash) e información personal (cifrados con password).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Protección de archivos.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cifrado de datos en reposo (al estar almacenados en los discos duros) de los datos para evitar su robo en caso de robo físico o de dispositivos virtuales.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tarjetas de crédito y seguridad bancaria en general.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Estos son tan sólo algunos ejemplos de los lugares en los que la criptografía juega un papel &lt;strong&gt;muy importante&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;esteganografía&quot;&gt;Esteganografía&lt;/h3&gt;

&lt;p&gt;La esteganografía es la técnica, relacionada con la criptografía, &lt;strong&gt;de hacer la información invisible&lt;/strong&gt;, generalmente ocultándola dentro de otro tipo de información.&lt;/p&gt;

&lt;p&gt;Con técnicas criptográficas comunes el que un atacante tenga disponible la información cifrada no hace necesariamente que nuestra información quede expuesta, a menos que el algoritmo criptográfico sea débil y el atacante tenga suficientes recursos para romperlo. En muchos casos incluso suponemos que los atacantes tienen acceso a esta información, como en el caso de la comunicación en internet en la que en cualquier parte de la red puede haber alguien interceptando nuestra información.&lt;/p&gt;

&lt;p&gt;Las técnicas esteganográficas buscan “desaparecer” completamente la información, hacerla invisible a través de ocultarla dentro de otros tipos de mensajes. En la antigüedad, por ejemplo en un libro que parecía hablar de magia, se ocultó un tratado acerca de criptografía y esteganografía, que sólo fue revelado hasta que se encontró la llave correcta.&lt;/p&gt;

&lt;p&gt;Con la llegada de los medios digitales, en la que todo puede ser representado por medio de bits, en realidad se puede ocultar información de cualquier tipo en cualquier otro tipo de mensajes, pero también se siguen usando medios físicos para ocultar información. Un ejemplo son los micro-puntos de algunas impresiones de manuscritos o información sensible repartido a personas de confianza que permiten identificar cada una de las copias entregadas a diferentes personas.&lt;/p&gt;

&lt;p&gt;Aunque la esteganografía y la criptografía son técnicas relacionadas, la más importante actualmente es la criptografía por su uso en la mayoría de los sistemas informáticos de la actualidad.&lt;/p&gt;

&lt;h2 id=&quot;por-qué-deberías-aprender-criptografía&quot;&gt;¿Por qué deberías aprender criptografía?&lt;/h2&gt;

&lt;p&gt;Ya mencionamos lo importante que es en los sistemas actuales. La mayoría de los lenguajes de programación, los desarrollos open source, como los frameworks web, muchas librerías, plataformas como servicio, etc. tienen funciones de seguridad y criptográficas incluídas.&lt;/p&gt;

&lt;p&gt;Pero no es suficiente con &lt;em&gt;ser usuario&lt;/em&gt; de estas cosas, ya que hasta los mecanismos y algoritmos mejor diseñados se pueden ser mal usados y hechos inseguros por la mala utilización.&lt;/p&gt;

&lt;p&gt;Conocer temas como los siguientes te permitirá elevar la calidad de tus desarrollos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¿Qué determina la seguridad de un algoritmo criptográfico?&lt;/li&gt;
  &lt;li&gt;¿Por qué es importante tener una llave de un tamaño correcto?&lt;/li&gt;
  &lt;li&gt;¿Qué algoritmo debo escoger para esta característica que tengo que desarrollar?&lt;/li&gt;
  &lt;li&gt;¿Cuáles son las principales características y diferencias de los algoritmos más usados?&lt;/li&gt;
  &lt;li&gt;¿Qué algoritmos nunca más debería usar?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;En este artículo sólo hemos tocado la definición de criptografía y hemos mencionado por qué es importante. En los siguientes empezaremos a hablar de las bases que nos permitirán comprender cómo funciona la criptografía y qué mecanismos son los que permiten que brinde seguridad mediante ocultar la información.&lt;/p&gt;

&lt;p&gt;En el próximo artículo hablaremos de la base de todos los sistemas criptográficos. Los números (pseudo)aleatorios y sus generadores.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="criptografía" /><category term="esteganografía" /><category term="seguridad" /><summary type="html">Aprende las bases de la criptografía para tenerla en cuenta en tus programas.</summary></entry><entry><title type="html">Entendiendo REST: Servicios cacheables</title><link href="https://blog.thedojo.mx/2019/10/27/entendiendo-rest-servicios-cacheables.html" rel="alternate" type="text/html" title="Entendiendo REST: Servicios cacheables" /><published>2019-10-27T00:00:00-05:00</published><updated>2019-10-27T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2019/10/27/entendiendo-rest-servicios-cacheables</id><content type="html" xml:base="https://blog.thedojo.mx/2019/10/27/entendiendo-rest-servicios-cacheables.html">&lt;p&gt;La tercera característica que &lt;a href=&quot;https://twitter.com/fielding&quot;&gt;Thomas R. Fielding&lt;/a&gt; (Roy Fielding a partir de ahora) establece para los sistemas &lt;strong&gt;REST&lt;/strong&gt; es la capacidad de que su información sea cacheable. Veamos lo que esto significa y por qué es una característica importante. Empecemos por definir el caché.&lt;/p&gt;

&lt;h2 id=&quot;qué-es-el-caché&quot;&gt;¿Qué es &lt;em&gt;el caché&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;Originalmente el caché se refiere a un tipo especial de memoria &lt;em&gt;muy rápida&lt;/em&gt; en los procesadores, que guarda &lt;em&gt;temporalmente&lt;/em&gt; información que tiene gran probabilidad de volver a ser utilizada &lt;em&gt;dentro de poco tiempo&lt;/em&gt; (en los procesadores hablamos de nano-segundos).&lt;/p&gt;

&lt;p&gt;Al evitar que el procesador vuelva a consultar la RAM (muy lenta en &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;comparación con la memoria caché&lt;/a&gt;), las operaciones se realizan a mucha mayor velocidad.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/k0t1e.png&quot; alt=&quot;Latencia de diferentes tipos de memoria&quot; /&gt;&lt;/p&gt;

&lt;p&gt;La memoria caché de los procesadores tiene una gran desventaja: &lt;strong&gt;es muy muy pequeña&lt;/strong&gt;. Esto presenta retos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¿Qué guardo aquí para maximizar la eficacia de este espacio de almacenamiento?&lt;/li&gt;
  &lt;li&gt;¿Cómo decido cuándo borrar o sobre-escribir la información que tengo aquí?&lt;/li&gt;
  &lt;li&gt;¿Qué pasa si la información original cambia mientras estoy ocupando los datos guardados en la memoria caché?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hablaremos más adelante de estas preguntas en nuestro propio contexto, pero hay técnicas para poder contestarlas con cierta eficacia, que los &lt;a href=&quot;http://user.it.uu.se/~yi/pdf-files/2014/euc14.pdf&quot;&gt;procesadores han logrado implementar&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Así que puedes pensar en el caché como en una memoria que es más rápida (aunque más limitada). Se utiliza con el objetivo de hacer un sistema más rápido y a veces más eficiente.&lt;/p&gt;

&lt;h2 id=&quot;caché-en-los-sistemas-rest&quot;&gt;Caché en los sistemas REST&lt;/h2&gt;

&lt;p&gt;Esta característica se basa en las dos que ya hablamos: &lt;a href=&quot;/2019/08/03/entendiendo-rest-servidor-sin-estado.html&quot;&gt;servicios sin estado&lt;/a&gt; y &lt;a href=&quot;/2019/07/04/entendiendo-rest-arquitectura-cliente-servidor.html&quot;&gt;arquitectura cliente-servidor&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lo que se define como “cacheabilidad” en los sistemas REST es la capacidad
de estos sistemas para &lt;em&gt;etiquetar&lt;/em&gt; de alguna forma las respuestas para que
otros mecanismos intermedios funcionen como un caché.&lt;/p&gt;

&lt;p&gt;Así el sistema puede atender más peticiones, en menos tiempo, con menos
recursos (comparado con un sistema sin caché).&lt;/p&gt;

&lt;p&gt;Estos sistemas o mecanismos intermedios (existen entre el cliente y el servidor) deben ser por lo general transparentes para los desarrolladores,
no deben afectar la manera en que los servicios se consumen.&lt;/p&gt;

&lt;p&gt;En sistemas web que usan &lt;strong&gt;HTTP&lt;/strong&gt; para comunicarse el sistema de “etiquetado” que permite que una respuesta sea cacheada son &lt;strong&gt;las cabeceras&lt;/strong&gt;. Estas permiten a los diferentes actores en el proceso de comunicación (servidor local, proxy, proxy reverso, navegador o cliente final, entre otros), saber quién debería cachear la información y por cuánto tiempo o cómo decidir si deben renovar la información. Las cabeceras HTTP comúnmente usadas para esto son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Expires&lt;/code&gt;: especifica hasta cuándo se puede considerar fresca o válida la información.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-control&lt;/code&gt;: Es usado para especificar directivas de caché que deben ser respetadas por todos lo puntos por los que pasa la información. Puedes ver los posibles valores y su especifacación aquí: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.9&quot;&gt;Cache-Control Header&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vary&lt;/code&gt;: es usada para indicar qué otras cabeceras se deben tomar en cuenta para decidir si el servidor puede reutilizar una respuesta o no.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Etag&lt;/code&gt;: identifica a una respueste de manera única, puede usarse para pedir una respuesta nueva de un mismo endpoint, y en combinación con la cabecera &lt;code class=&quot;highlighter-rouge&quot;&gt;If-None-Match&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Existen otras cabeceras usadas para lograr un control correcto del caché como &lt;code class=&quot;highlighter-rouge&quot;&gt;If-Modified-Since&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;ventajas-del-caché&quot;&gt;Ventajas del caché&lt;/h2&gt;

&lt;p&gt;El caché se establece como una de las características de REST porque proporciona ventajas para el uso y la escalabilidad de los sistemas. Veamos algunas de ellas.&lt;/p&gt;

&lt;h3 id=&quot;aumenta-la-percepción-de-velocidad&quot;&gt;Aumenta la percepción de velocidad&lt;/h3&gt;

&lt;p&gt;Al guardar las respuestas que es más probable que vuelvan a salir, un sistema REST puede contestar una gran cantidad de sus peticiones a la velocidad que el caché lo permita, es decir, muy rápido.&lt;/p&gt;

&lt;h3 id=&quot;consumo-de-recursos-reducido&quot;&gt;Consumo de recursos reducido&lt;/h3&gt;

&lt;p&gt;El uso caché se parece mucho a una técnica de programación llamada &lt;strong&gt;dynamic programming&lt;/strong&gt; que consiste en guardar temporalmente los resultados de operaciones costosas en tiempo. Esto permite que
nos ahorremos el procesamiento de muchas respuestas que no se necesitan
de nuevo porque están almacendas. Además se reduce el ancho de banda
consumido porque muchas peticiones ni siquiera tienen que llegar al servidor.&lt;/p&gt;

&lt;h3 id=&quot;sistemas-más-fáciles-de-escalar&quot;&gt;Sistemas más fáciles de escalar&lt;/h3&gt;

&lt;p&gt;Los sistemas que usan caché son capaces de aguantar más peticiones
simultáneas por la razón que vimos anteriormente: se reduce el consumo de recursos. Además, si se require crecer el sistema se deben poner menos recursos. Para algunos sistemas, el caché es lo único que tiene que crecer
cuando se requiere atender a más usuarios simultáneos.&lt;/p&gt;

&lt;h2 id=&quot;retos-de-cachear&quot;&gt;Retos de cachear&lt;/h2&gt;

&lt;p&gt;Toda solución tecnológica implica ventajas y desventajas. Entonces ¿qué desventajas o retos implica usar un sistema de caché?&lt;/p&gt;

&lt;h3 id=&quot;frescura&quot;&gt;Frescura&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sólo hay dos cosas difíciles en Ciencias de Computación: invalidación de caché y nombrar cosas. - Phil Karlton&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;El reto más grande e importante de tener un sistema de caché es lograr un
equilibrio entre mantener la información el mayor tiempo posible y tener
información correcta y actualizada. Si se almacena en caché por demasiado
tiempo algo, esta información se vuelve vieja y por lo tanto puede estar desactualizada. Por el otro lado si se guarda por muy poco tiempo puede 
llevar a que los sistemas de caché se sub-utilicen y provean pocos
beneficios.&lt;/p&gt;

&lt;h3 id=&quot;diseño-del-sistema&quot;&gt;Diseño del sistema&lt;/h3&gt;

&lt;p&gt;Designar qué partes del sistema pueden ser cacheables y asignar los
etiquetados de las respuestas correctamente puede aumentar la complejidad del sistema en general.&lt;/p&gt;

&lt;h3 id=&quot;inconsistencia&quot;&gt;Inconsistencia&lt;/h3&gt;

&lt;p&gt;El uso de caché puede llevar a inconsistencias de información entre diferentes clientes por periodos de tiempo de diferente duración. Esto es en parte consecuencia de la dificultad de mantener el caché fresco, pero además tiene que ver con la manera en que los clientes piden la información. &lt;strong&gt;Si tus clientes no pueden soportar la mínima variación en la información porque tendría consecuencias graves, es mejor no cachear.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;El caché es una parte olvidada de los sistemas REST, el constraint menos mencionado. Pero es importante que les permite funcionar mejor cuando tenemos bastante carga. Mantenerlo funcionando bien es un reto, pero los sistemas que quieren ser escalables y resistentes deben implementar alguna forma de cachear.&lt;/p&gt;

&lt;p&gt;Roy Fielding menciona que es importante porque cualquier
sistema expuesto a clientes desconocidos tiene el peligro de recibir una
gran cantidad de carga súbitamente, y si tu servicio no está preparado o es
fácil de escalar, fallarás.&lt;/p&gt;

&lt;p&gt;Si quieres leer un artículo más completo con otras referencias sobre el caché en REST y en HTTP te recomiendo &lt;a href=&quot;https://odino.org/rest-better-http-cache/&quot;&gt;REST better: HTTP Cache&lt;/a&gt;, en inglés.&lt;/p&gt;

&lt;p&gt;En el siguiente artículo veremos la cuarta restricción de los sistemas REST: la interfaz uniforme, la más amplia de las restricciones, pero una de las más útiles.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><summary type="html">Los servicios REST deben ser cacheables, aprendamos lo que esto significa y cómo podemos lograrlo.</summary></entry><entry><title type="html">El arte de resolver problemas: la heurística</title><link href="https://blog.thedojo.mx/2019/10/03/el-arte-de-resolver-problemas-la-heuristica.html" rel="alternate" type="text/html" title="El arte de resolver problemas: la heurística" /><published>2019-10-03T00:00:00-05:00</published><updated>2019-10-03T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2019/10/03/el-arte-de-resolver-problemas-la-heuristica</id><content type="html" xml:base="https://blog.thedojo.mx/2019/10/03/el-arte-de-resolver-problemas-la-heuristica.html">&lt;blockquote&gt;
  &lt;p&gt;La heurística habla del &lt;strong&gt;comportamiento humano&lt;/strong&gt; frente a los problemas. - George Polya&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;En un &lt;a href=&quot;/2019/09/27/tecnicas-para-resolver-problemas.html&quot;&gt;artículo anterior&lt;/a&gt; analizamos la estructura básica de un problema y la estructura de resolución que George Polya propone para intentar resolverlos.&lt;/p&gt;

&lt;p&gt;Polya analiza a fondo la estructura del proceso de resolución de problemas. Aquí hablaremos de &lt;strong&gt;la heurística&lt;/strong&gt;, de la que escribió en &lt;a href=&quot;https://math.hawaii.edu/home/pdf/putnam/PolyaHowToSolveIt.pdf&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;“How to solve it”&lt;/strong&gt;&lt;/a&gt;, un compendio que pensó originalmente como un análisis de esta.&lt;/p&gt;

&lt;h2 id=&quot;definición&quot;&gt;Definición&lt;/h2&gt;

&lt;p&gt;La palabra heurística viene de una raíz griega que transmite la idea de &lt;strong&gt;descubrimiento o invención&lt;/strong&gt;. La heurística históricamente ha estado relacionada con &lt;strong&gt;estudiar los medios por los que se descubre o inventa algo&lt;/strong&gt;. Su campo de estudio abarca la lógica, la psicología y la filosofía, pero no se puede acotar a ninguna de las tres áreas.&lt;/p&gt;

&lt;p&gt;Polya estudia y define la heurística moderna como &lt;em&gt;el arte de resolver problemas&lt;/em&gt;, porque en eso consiste el proceso: descubrir una solución(en los problemas en los que hay que &lt;em&gt;encontrar algo&lt;/em&gt;) o inventar algo (en los problemas en los que hay que &lt;em&gt;crear una demostración&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Podemos echar mano de lo que nos enseña al atacar problemas muy difíciles de los que no tenemos la mínima idea de cómo resolver o no podemos idear un plan confiable para resolverlos (recuerda que crear un plan es el punto medular de la resolución de un problema).&lt;/p&gt;

&lt;h2 id=&quot;heurística-moderna&quot;&gt;Heurística moderna&lt;/h2&gt;

&lt;p&gt;La heurística actualmente busca entender el proceso de resolución de problemas, pero particularmente las operaciones mentales relacionadas con ese proceso.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;La experiencia en la resolución de problemas u observar a otros resolver problemas debe ser la base de la heurística. - G. Polya&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Se busca encontrar patrones y propiedades comunes en una gran variedad de problemas, por lo que se puede decir que la heurística tiende a la generalidad, estudia procedimientos que son independientes del dominio del problema.
Polya habla de múltiples métodos y procedimientos para avanzar en la resolución de un problema complicado.&lt;/p&gt;

&lt;p&gt;Analicemos algunos de ellos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Variación del problema&lt;/strong&gt;. ¿Puedo variar por lo menos temporalmente alguna de las partes del problema? ¿Puedo cambiar los datos, las condiciones o la solución?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Descomposición y recombinación&lt;/strong&gt;. Esta operación mental implica entender y separar las partes esenciales de un problema y tratar de re-crearlo con un nuevo entendimiento o crear un problema ligeramente diferente.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Regresar a las definiciones&lt;/strong&gt;. Comprender los términos usados en cada parte del problema a veces implicará que busquemos lo que algo significa desde sus raíces. Esto nos puede ayudar a entender mejor el problema así como a introducir elementos auxiliares que ayuden en la resolución.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Generalización, especialización y analogías&lt;/strong&gt;. Estas tres operaciones son una forma de variar un problema. ¿Puedo hacer el problema más amplio, para resolver un caso más general y después aplicar los resultados o el método a mi problema original? ¿Existe un problema similar al que estoy resolviendo que pueda resolver más fácilmente?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Notación adecuada&lt;/strong&gt;. Una vez entendido el problema, sobre todo para problemas matemáticos, es muy importante introducir notación que nos pueda ayudar a trabajar sobre el problema. Para los problemas matemáticos y en ciencias en general, ya existen estas notaciones estándar. Para nuestros problemas tenemos que inventar una que la mayoría de los implicados puede entender y usar.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Suponer, pero comprobar las suposiciones&lt;/strong&gt;. Para avanzar en la resolución de un problema muchas veces hay que dar cosas por supuesto, como en el caso de las comprobaciones por reducción al absurdo. Polya afirma que no está mal suponer cosas temporalmente mientras más adelante encontremos una forma de comprobar o rechazar esas suposiciones.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Trabajar en reversa&lt;/strong&gt;. Muchas veces sabemos &lt;em&gt;como luce&lt;/em&gt; la solución, o tenemos que comprobar que una solución supuesta es correcta. Trabajar en reversa significa avanzar de la solución hasta nuestro estado actual, trabajando paso por paso hasta poder encontrar la cadena de transformaciones necesarias para conectar esos estados.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Aspectos psicológicos: determinación, esperanza y éxito&lt;/strong&gt;. Al principio mencionamos que la heurística es también trataba con aspectos psicológicos. Polya afirma que sería un error considerar que los problemas son ejercicios puramente intelectuales. En el proceso de resolución influye mucho los sentimientos y emocionses. Los tres puntos mencionados aquí son muy importantes para la resolución de un problema. Primero, debemos &lt;em&gt;desear&lt;/em&gt; resolver el problema, esto es la determinación. Segundo, debemos creer que somos &lt;em&gt;capaces&lt;/em&gt; de resolver el problema y que este tiene solución. Y tercero, en lo relacionado con problemas intelectuales es muy difícil perseverar si no se experimenta una razonable dosis de éxito de vez en cuando. Para esto es necesario aplicar algunas de las técnicas mencionadas arriba.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Como puedes ver, la heurística es práctica. Además la heurística aplicada a la enseñanza y a la puede tener efectos positivos, ya que ayuda a las personas a aprender a pensar mejor.&lt;/p&gt;

&lt;h2 id=&quot;razonamiento-heurístico&quot;&gt;Razonamiento Heurístico&lt;/h2&gt;

&lt;p&gt;Aplicar las técnicas antes mencionadas tiene un efecto en la forma de resolver los problemas: en algunos de los pasos de la solución aceptamos soluciones supuestas, incompletas, relacionadas vagamente con el problema o parcialmente erróneas con tal de avanzar en la solución y el entendimiento del problema y de generar nuevas ideas/éxitos para mantener y aumentar la motivación.&lt;/p&gt;

&lt;p&gt;Esto no quiere decir que la heurística acepte soluciones erróneas, estos pasos son temporales, y las soluciones finales deben ser comprobadas con el mayor rigor posible.&lt;/p&gt;

&lt;h2 id=&quot;algoritmos-heurísticos&quot;&gt;Algoritmos heurísticos&lt;/h2&gt;

&lt;p&gt;Ahora hablemos de aprovechar estas ideas para la programación, con una clase de algoritmos conocidos como algoritmos heurísticos.&lt;/p&gt;

&lt;p&gt;Un algoritmo heurístico en vez de garantizar siempre la mejor solución en cada paso del programa, acepta soluciones parciales o suficientemente buenas. Este tipo de algoritmos funciona muy bien en casos donde hay demasiadas soluciones posibles como para probarlas todas (fuerza bruta) o muchas de ellas (como los algoritmos de &lt;em&gt;backtracking&lt;/em&gt;) y no hay ningún algoritmo establecido conocido que resuleva el problema  o se haya demostrado que esta solución es imposible.&lt;/p&gt;

&lt;p&gt;La principal diferencia a tener en cuenta cuando hablamos o tratamos con este tipo de algoritmos es que &lt;strong&gt;no garantizan la respuesta correcta o la respuesta óptima&lt;/strong&gt;, aunque en algunos casos son la mejor forma de lograrlo. Fuera de la programación, la heurística nos ayuda a llegar a la respuesta correcta aceptando temporalmente soluciones intermedias no óptimas, semi-erróneas o incompletas, pero con soluciones finales &lt;em&gt;*que se pueden verificar como correctas rigurosamente&lt;/em&gt;. No es así con los algoritmos heurísticos en la programación, y he aquí por lo que el nombre puede confundirnos.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;La heurística es un campo de estudio valioso sobre todo para la vida moderna y para el desarrollo de software porque puede ayudarnos a estructurar nuestros esfuerzos en la resolución de los problemas que nos enfrentamos.&lt;/p&gt;

&lt;p&gt;En el siguiente y último artículo de la serie analizaremos más técnicas usadas en la resolución de problemas de las que Polya habla en el libro “How to Solve It”.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="polya" /><category term="problemas" /><category term="how_to_solve_it" /><category term="heurística" /><category term="heuristics" /><summary type="html">La heurística te ayudará a resolver mejor los problemas que se te presentan como programador. Veamosla más detenidamente.</summary></entry><entry><title type="html">Técnicas para resolver problemas</title><link href="https://blog.thedojo.mx/2019/09/27/tecnicas-para-resolver-problemas.html" rel="alternate" type="text/html" title="Técnicas para resolver problemas" /><published>2019-09-27T00:00:00-05:00</published><updated>2019-09-27T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2019/09/27/tecnicas-para-resolver-problemas</id><content type="html" xml:base="https://blog.thedojo.mx/2019/09/27/tecnicas-para-resolver-problemas.html">&lt;p&gt;Todos los desarrolladores nos hemos encontrado con problemas que nos dejan perplejos y que no tenemos idea de por dónde empezar a resolver.&lt;/p&gt;

&lt;p&gt;George Polya fue uno de los matemáticos más prolíficos del Siglo XX, un matemático de primera clase (de esos que descubren e inventan cosas, y para algunos, &lt;strong&gt;el matemático más influyente del siglo&lt;/strong&gt;) pero que, a diferencia de muchos otros, mantenía un interés por la educación y la enseñanza de las matemáticas, algo muy peculiar.&lt;/p&gt;

&lt;p&gt;Escribió varios libros, entre ellos está &lt;strong&gt;“How to solve it”&lt;/strong&gt; un tratado de 4 partes en el que explica de manera muy detallada cómo resolver problemas matemáticos principalmente, pero también cómo aplicar este conocimiento a otras áreas de la vida.&lt;/p&gt;

&lt;p&gt;Las técnicas explicadas por Polya te pueden ayudar a desarrollar tus capacidades de resolución de problemas.&lt;/p&gt;

&lt;p&gt;Empecemos por hablar de la estructura los problemas de los que Polya habla en su libro.&lt;/p&gt;

&lt;h2 id=&quot;estructura-de-un-problema&quot;&gt;Estructura de un problema&lt;/h2&gt;

&lt;p&gt;Polya enseña que un problema tiene tres partes:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Los datos&lt;/strong&gt;. Es la información que tenemos disponible para resolver el problema.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Las condiciones&lt;/strong&gt;. Describen la relación que existe entre los datos y la solución, pero también la forma, los límites y características de la solución buscada.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;La incógnita o lo desconocido&lt;/strong&gt;. Es la información que buscamos y que cumple con las condiciones del problema.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Es muy importante conocer la composición de un problema para poder aplicar las técnicas descritas en el libro. Cualquier problema matemático &lt;strong&gt;debería cumplir con estas características&lt;/strong&gt;, pero no todos los problemas de la vida real cumplen con esta estructura tal y como la necesitamos; por esta razón deberíamos desarrollar la capacidad de entender los problemas que se nos presentan y estructurarlos lo mejor posible según esta definición para facilitarnos la vida posteriormente.&lt;/p&gt;

&lt;p&gt;Para resolver un problema deberías ser capaz de contestar las siguientes preguntas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¿Qué estoy buscando? -&amp;gt; &lt;strong&gt;¿Cuál es la incógnita?&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;¿Qué datos tengo disponibles? -&amp;gt; &lt;strong&gt;¿Son suficientes los datos que tengo para resolver el problema?&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;¿Qué condiciones tiene que cumplir la incógnita? -&amp;gt; &lt;strong&gt;¿Es posible cumplir con esta condición?&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;¿Qué relación hay entre los datos y la incógnita?&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Esta estructura sienta las bases para lo que viene. Ahora hablemos de de los tipos de problemas de los que Polya hace distinción.&lt;/p&gt;

&lt;h2 id=&quot;tipos-de-problemas&quot;&gt;Tipos de problemas&lt;/h2&gt;

&lt;p&gt;Polya hace la distinción entre dos tipos diferentes de problemas que hay que tratar de resolver de manera ligeramente diferente aunque la estructura sea la misma.&lt;/p&gt;

&lt;h3 id=&quot;1-problemas-para-encontrar&quot;&gt;1. Problemas para encontrar&lt;/h3&gt;

&lt;p&gt;Estos son los problemas básicos que nos ponían en la escuela primaria: “&lt;strong&gt;Hallar&lt;/strong&gt; el área de un terreno cuadrado de 10m por lado”, “&lt;strong&gt;Encuentra&lt;/strong&gt; la diámetro de una circunferencia con un perímetro de 12cm”.&lt;/p&gt;

&lt;p&gt;En este tipo de problemas hay que encontrar un resultado, que puede ser numérico o no. Estos son los problemas con los que nos encontramos mayormente en áreas del conocimiento muy exploradas.&lt;/p&gt;

&lt;p&gt;Como programadores podríamos tener estos ejemplos de este tipo de problemas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¿Qué complejidad tiene este algoritmo que acabo de programar?&lt;/li&gt;
  &lt;li&gt;¿A cuántos usuarios simultáneos podré atender con este servidor con 4GB de RAM?&lt;/li&gt;
  &lt;li&gt;¿Cuánto tiempo va a tardar en subir mi millón de archivos si lo vuelvo paralelo? ¿Cuánto va a tardar si no lo paralelizo?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Varios de estos problemas suenan demasiado simples porque ya los tenemos bien trabajados a base de repetición. Pero otros que no tienen una respuesta numérica pueden ser un poco más complicados:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¿Qué base de datos debería usar para servir notificaciones en tiempo real?&lt;/li&gt;
  &lt;li&gt;¿Qué lenguaje de programación debo usar para un sistema que estará emebebido en un millón de dispositivos electrónicos mandando notificaciones críticas cada segundo?&lt;/li&gt;
  &lt;li&gt;¿Qué sistema de comunicación puedo usar entre dos dispositivos que no cuentan con una conexión confiable a internet?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En los ejemplos anteriores encontrar una solución concreta a las preguntas planteadas permite avanzar.&lt;/p&gt;

&lt;h3 id=&quot;2-problemas-para-demostrar&quot;&gt;2. Problemas para demostrar&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Demuestre que la línea de mayor longitud que toca dos puntos de una circunferencia pasa por el centro del círculo”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Esto es un ejemplo de un problema para demostrar. Estos implican la comprobación o refutación de una aserción (&lt;em&gt;hipótesis&lt;/em&gt;) enunciada en el problema. Estos problemas generalmente nos los ponían en la preparatoria o universidad, por su naturaleza son un poco más difíciles en general.&lt;/p&gt;

&lt;p&gt;Para un desarrollador podríamos poner problemas para demostrar como:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Demuestra que es imposible un bloqueo mutuo entre procesos con el algoritmo usado actualmente”.&lt;/li&gt;
  &lt;li&gt;“¿Cómo sabemos que evitamos todas las condiciones de carrera en el sistema actual?”&lt;/li&gt;
  &lt;li&gt;“Comprueba que el máximo tiempo que puede tardar el sistema en responder es menor que X.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Estos problemas requieren soluciones más generales y abstractas en general. Espero que con estos ejemplos haya quedado clara la diferencia entre los diferentes tipos de problemas.&lt;/p&gt;

&lt;h3 id=&quot;problemas-matemáticos-acertijos-y-problemas-de-la-vida-real&quot;&gt;Problemas matemáticos, acertijos y problemas de la vida real&lt;/h3&gt;

&lt;p&gt;Polya habla en sus libro sobre todo de un tipo específico de problemas: &lt;strong&gt;los problemas matemáticos&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Un problema matemático bien definido cuenta con:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Datos suficientes para resolución&lt;/li&gt;
  &lt;li&gt;No tiene datos sobrantes&lt;/li&gt;
  &lt;li&gt;Condiciones no contradictorias o imposibles de cumplir&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Por extensión, &lt;strong&gt;los acertijos&lt;/strong&gt; cumplen con las mismas características, y se dan algunos de ejemplos de ellos en el libro.
Pero los problemas de la vida real son muy diferentes, ya que estos pueden no cumplir con las características completas
de un problema bien definido. Así que uno de los pasos previos para resolver un problema de la vida real es intentar definir lo mejor posible el problema por resolver y completarlo en caso de que falte algo.&lt;/p&gt;

&lt;h2 id=&quot;cómo-empezar-a-resolver-un-problema&quot;&gt;Cómo empezar a resolver un problema&lt;/h2&gt;
&lt;p&gt;Polya plantea cuatro etapas de resolución de un problema:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Entendimiento&lt;/li&gt;
  &lt;li&gt;Planeación&lt;/li&gt;
  &lt;li&gt;Ejecución&lt;/li&gt;
  &lt;li&gt;Retrospectiva&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hablemos de cada una, para entender claramente cómo podemos mejorar nuestras posibilidades de resolución de un problema.&lt;/p&gt;

&lt;h3 id=&quot;entendimiento&quot;&gt;Entendimiento&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Es tonto contestar una pregunta que no entiendes. Es triste trabajar por un fin que no deseas. - &lt;strong&gt;G. Polya&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;El entendimiento del problema consiste primero en asegurarnos de que &lt;strong&gt;entendemos el planteamiento verbal del problema&lt;/strong&gt;, si no tenemos ni siquiera un planteamiento verbal, debemos empezar por crearlo.&lt;/p&gt;

&lt;p&gt;Para decir que comprendemos el problema, tenemos que conocer los datos que se dan, las condiciones a satisfacer y la incógnita o lo que hay que demostrar.&lt;/p&gt;

&lt;p&gt;Esta parte puede llevar gran parte del tiempo total dedicado al problema, ya que es el fundamento de los próximos pasos, sin la que no se puede continuar.&lt;/p&gt;

&lt;p&gt;### Planeación&lt;/p&gt;

&lt;p&gt;El siguiente paso es trazar un plan para atacar el problema. El plan consiste en saber que transformaciones, derivaciones y combinaciones tenemos que hacer con los datos para llegar a la solución esperada.&lt;/p&gt;

&lt;p&gt;Esta es la parte más difícil, ya que implica conocimiento profundo del problema. Para Polya, concebir un plan es el mayor logro en la resolución de un problema. Cuando lo concebimos parece que tenemos una “idea brillante”.&lt;/p&gt;

&lt;p&gt;Pero es casi imposible tener una idea brillante cuando sabemos muy poco del tema. Las buenas ideas están basadas en conocimiento y experiencia previa. Por eso conviene preguntarse: &lt;strong&gt;¿Conozco o resuelto un problema relacionado o similar?&lt;/strong&gt;. Hablaremos de otras preguntas que nos pueden ayudar a concebir un plan más adelante.&lt;/p&gt;

&lt;p&gt;### Ejecución&lt;/p&gt;

&lt;p&gt;Es hora de llevar a cabo los pasos establecidos en la planeación. En esta etapa hay que ejecutar cada uno de los pasos que establecimos en la planeación de ejecución del problema. Polya dice que aquí es donde &lt;strong&gt;hay que ser rigurosos con lo que hacemos&lt;/strong&gt;, verificando que lo que hacemos tenga sentido y sea estrictamente correcto. ¿Puedes comprobar en cada paso que es correcto lo que estás haciendo?&lt;/p&gt;

&lt;p&gt;### Retrospectiva&lt;/p&gt;

&lt;p&gt;En este paso hay que &lt;strong&gt;examinar el resultado&lt;/strong&gt;. ¿Puedes probar que el resultado final es correcto?
Además podemos ver si podemos hacer algo diferente, si nuestro resultado cumple con todo lo esperado y si podemos encontrar o derivar el resultado de alguna otra forma ahora que ya sabemos cuál es.&lt;/p&gt;

&lt;p&gt;Este paso también sirve para verificar si el resultado o el método que usamos para resolverlo nues puede ayudar con algún otro problema que tengamos que resolver.&lt;/p&gt;

&lt;h3 id=&quot;las-preguntas-de-polya&quot;&gt;Las preguntas de Polya&lt;/h3&gt;

&lt;p&gt;Polya estableció una serie de preguntas que pueden guiarte en la solución de un problema, muy relacionadas con los pasos de los que acabamos de hablar. Estas preguntas las repite vez tras vez en el libro y en verdad son iluminadoras si estás atorado en algún problema que no puedes resolver. A continuación las listamos.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¿He resuelto un problema &lt;strong&gt;relacionado&lt;/strong&gt;? ¿Conozco un &lt;strong&gt;problema que se aproxime&lt;/strong&gt;?&lt;/li&gt;
  &lt;li&gt;¿Estoy usando todos los datos?&lt;/li&gt;
  &lt;li&gt;¿Puedo cambiar algo del problema para hacerlo más fácil?
    &lt;ul&gt;
      &lt;li&gt;¿Puedo cambiar los datos?&lt;/li&gt;
      &lt;li&gt;¿Puedo cambiar las condiciones?&lt;/li&gt;
      &lt;li&gt;¿Puedo cambiar la incógnita?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;para-recordar&quot;&gt;Para recordar&lt;/h2&gt;

&lt;p&gt;Para resolver un problema:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Asegúrate de entender el problema completamente: qué datos tienes, qué relación hay entre los datos y la incógnita y lo que tienes que encontrar.&lt;/li&gt;
  &lt;li&gt;Planea cómo vas a atacar el problema&lt;/li&gt;
  &lt;li&gt;Si estás detenido en la resolución de un problema puedes:
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Variar los datos&lt;/strong&gt;, las condiciones o el resultado esperado.&lt;/li&gt;
      &lt;li&gt;Pensar en otros problemas que se le parezcan: puedes usar el método que usaste para resolverlos o el resultado.&lt;/li&gt;
      &lt;li&gt;Aceptar soluciones parciales, parcialmente erróneas o asumidas.&lt;/li&gt;
      &lt;li&gt;Genera nuevas ideas y re-evalúa el problema y el plan a la luz de cada nuevo paso.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Aprovecha cualquier idea aunque suene disparatada.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En el siguiente post hablaremos de 5 cosas más de las que Polya habla en su libro: heurística, inducción, deducción, análisis y síntesis.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="matemáticas" /><category term="maths" /><category term="polya" /><category term="books" /><category term="libros" /><summary type="html">¿Cuántas veces te has enfrentado a problemas de los que no tienes ni idea de cómo empezar a resolver? George Polya escribió un libro completo sobre eso en 1928. Hablemos de las principales lecciones que podemos sacar.</summary></entry><entry><title type="html">¿Por qué deberías aprender Go?</title><link href="https://blog.thedojo.mx/2019/09/01/por-que-deberias-aprender-go.html" rel="alternate" type="text/html" title="¿Por qué deberías aprender Go?" /><published>2019-09-01T00:00:00-05:00</published><updated>2019-09-01T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2019/09/01/por-que-deberias-aprender-go</id><content type="html" xml:base="https://blog.thedojo.mx/2019/09/01/por-que-deberias-aprender-go.html">&lt;blockquote&gt;
  &lt;p&gt;Go es &lt;strong&gt;eficiente, escalable y productivo&lt;/strong&gt;. - &lt;em&gt;Rob Pike&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Go es un lenguaje que llama la atención por algunos rumores que hay acerca de él, como, por ejemplo, que es el lenguaje que va a matar a C, o que es muy muy rápido y poderoso. En este artículo vamos a hablar de qué cosas son ciertas y en qué casos te conviene aprender Go.&lt;/p&gt;

&lt;p&gt;Empecemos hablando de cómo y por qué nació.&lt;/p&gt;

&lt;h2 id=&quot;historia-de-go&quot;&gt;Historia de Go&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Go fue diseñado por Google para resolver sus problemas, y Google tiene &lt;em&gt;grandes&lt;/em&gt; problemas. - &lt;em&gt;Rob Pike&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Go fue creado dentro de Google por un grupo de desarrolladores de software y científicos de la computación &lt;strong&gt;MUY experimentados&lt;/strong&gt;. Las tres personas que lo iniciaron a pensar y diseñar en 2007 fueron Robert Griesemer, Rob Pike y &lt;strong&gt;Ken Thompson&lt;/strong&gt; (sí, el co-creador de UNIX, grep y muchas cosas más). De ese tamaño son las personas que lo diseñaron, y así se siente el lenguaje cuando lo usas.&lt;/p&gt;

&lt;p&gt;Después de una serie de correos y discusiones sobre el diseño, empezaron a trabajar en él y &lt;a href=&quot;https://www.youtube.com/watch?v=rKnDgT73v8s&quot;&gt;lo presentaron como proyecto Open Source en 2009&lt;/a&gt;, a partir de ahí muchas personas tanto de dentro como de fuera de Google han contribuido a su desarrollo.&lt;/p&gt;

&lt;h2 id=&quot;características-de--go&quot;&gt;Características de  Go&lt;/h2&gt;

&lt;p&gt;Go fue concebido pensando en los problemas que los diseñadores veían en los sistemas de Google: su proceso de desarrollo estaba entorpecido por las herramientas que usaban. Según Rob Pike, todo era demasiado lento: demasiado lento de compilar, demasiado lento de construir, demasiado lento de pensar. Cuando decimos que el tiempo de compilación era demasiado largo nos referimos a que podía llegar a tomar &lt;em&gt;varias horas&lt;/em&gt; para compilar un sistema.&lt;/p&gt;

&lt;p&gt;También había una “explosión de complejidad”. Así que Go fue pensado para ser simple, de una “simplicidad radical”. Por lo tanto, carece de características que otros lenguajes sí tienen, pero hacen que los programas sean complejos.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;La simplicidad es la clave del buen software. - &lt;em&gt;The Go Programming Language&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Analicemos las características de Go, un lenguaje pensado para trabajar en sistemas muy grandes de manera simple.&lt;/p&gt;

&lt;h3 id=&quot;procedural-con-flexibilidad-para-orientación-a-objetos&quot;&gt;Procedural, con flexibilidad para orientación a objetos&lt;/h3&gt;

&lt;p&gt;El paradigma principal de Go es el procedural se parece mucho a C en este aspecto. Sus principales medios de organización son las funciones y los paquetes, aunque permite crear un tipo débil de organización muy parecida a los objetos mediante &lt;code class=&quot;highlighter-rouge&quot;&gt;structs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Aquí puedes ver un ‘Hello world’:&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;¡Hola Go!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;tipado-estático-y-fuerte&quot;&gt;Tipado estático y fuerte&lt;/h3&gt;

&lt;p&gt;Go es un lenguaje fuertemente tipado, lo cuál quiere implica varias cosas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;La declaración de variables implica el tipo de valor que estará asociado a esta instancia del nombre, por lo que no puede usarse para guardar otro tipo de valor. En Go no necesariamente se tiene que decir explícitamente el tipo de valor a usarse, puede ser inferido:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;n&quot;&gt;miNombre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Héctor&quot;&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// La variable es un string&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Esto es verificado en tiempo de compilación, por lo que podrás estar tranquilo de que Go no te dejará correr programas usando variables como lo que no son.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;No existe la conversión o forzamiento de tipos automática e implícita, como en JS, que intenta realizar la operación aunque los tipos de valor usados no tengan sentido en la operación. En Go, si intentas hacer una operación con tipos no compatibles el programa puede no compilar o fallar en tiempo de ejecución.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;rápida-compilación&quot;&gt;Rápida compilación&lt;/h3&gt;

&lt;p&gt;Pensado para sistemas muy grandes, justo como los desarrollados en Google, Go se toma en serio el tiempo de complicación y es muy rápido al compilar los programas, a diferencia de Java, C o C++. Esto está apoyado por tres pilares:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Las dependencias están puestas al principio de cada archivo, por lo que no hay que buscar en todo el programa por dependencias perdidas.&lt;/li&gt;
  &lt;li&gt;Las dependencias no forman ciclos, por lo que pueden organizarse para que sean compiladas independientemente, incluso de manera paralela.&lt;/li&gt;
  &lt;li&gt;El programa objeto compilado de cada paquete exporta información útil para sus dependencias que puede ser usada sin tener que leer todo el paquete.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;manejo-de-dependencias-y-paquetes&quot;&gt;Manejo de dependencias y paquetes&lt;/h3&gt;
&lt;p&gt;Go tiene en su biblioteca estándar más de 100 paquetes y la comunidad de Go cada vez contribuye más paquetes. Go viene con la herramienta para la línea de comandos &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt; que es fácil de usar para manejar proyectos creados con Go. La herramienta &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt; nos ayuda a administrar nuestras dependencias: descargarlas, limpiarlas e instalarlas.&lt;/p&gt;

&lt;h3 id=&quot;manejo-de-memoria&quot;&gt;Manejo de memoria&lt;/h3&gt;
&lt;p&gt;Go tiene manejo automático de memoria, lo que quiere decir que tal como en Java o Python, no tienes que preocuparte de liberar la memoria manualmente. Sin embargo, esta característica lo hace poco práctico para sistemas que requieran tratamiento de datos en tiempo real demasiado fuerte y preciso.&lt;/p&gt;

&lt;h2 id=&quot;concurrencia&quot;&gt;Concurrencia&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/v1567320490/Go-routines-gopher_vgcpbt.jpg&quot; alt=&quot;La mascota de Go haciendo el trabajo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A esta característica decidimos dedicarle un poco más de espacio. Debido a que el mundo de la computación ha cambiado desde que se escribieron los primeros programas, en los que se contaba con un sólo procesador, el equipo de Go le dio gran importancia a la capacidad de &lt;strong&gt;crear programas con un muy buen diseño concurrente&lt;/strong&gt;. Eventualmente estos programas podrían correr en paralelo aprovechando los sistemas de computación que existen actualmente, con múltiples procesadores.&lt;/p&gt;

&lt;p&gt;Go permite crear procesos concurrente de manera muy sencilla:&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Eso es todo. Go ejecutará la función &lt;code class=&quot;highlighter-rouge&quot;&gt;myFunc&lt;/code&gt; de manera concurrente (se ejecuta de manera independiente al programa principal o a otras funciones concurrentes). Esto es una &lt;strong&gt;gorutine&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Go soporta dos modelos de concurrencia:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Comunicación de procesos secuenciales&lt;/strong&gt; (Communicating Sequential Processes - CSP), en la que cada proceso tiene sus propias variables, y se transfieren información entre ellos mediante mensajes. En el caso de Go es a través de &lt;em&gt;canales&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Multihilo con memoria compartida&lt;/strong&gt;. En este tipo de concurrencia todos los procesos escriben sobre el mismo espacio de memoria, es decir, comparten variables, pero debe haber algúna forma de coordinación entre ellos para que no choquen ni se bloqueen mutuamente al tomar un recurso.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La concurrencia es uno de los puntos más fuertes de Go.&lt;/p&gt;

&lt;h2 id=&quot;ventajas-de-go-sobre-otros-lenguajes&quot;&gt;Ventajas de Go sobre otros lenguajes&lt;/h2&gt;

&lt;p&gt;Hablemos de en qué casos querrías usar Go.&lt;/p&gt;

&lt;h3 id=&quot;eficiencia-al-correr&quot;&gt;Eficiencia al correr&lt;/h3&gt;
&lt;p&gt;Go no corre sobre ninguna máquina virtual. Crea ejecutables para los sistemas operativos a los que apunta, que contienen todo lo necesario para poder ejecutarse sin necesidad de tener algo instalado allí. Al ser compilado, Go es mucho más eficiente para correr que otros lenguajes interpretados, como JS, Python o Ruby. Consume menos memoria y su velocidad se acerca a la de C.&lt;/p&gt;

&lt;h3 id=&quot;legibilidad&quot;&gt;Legibilidad&lt;/h3&gt;
&lt;p&gt;Go fue pensado para ser &lt;em&gt;simple&lt;/em&gt;. Sus estructuras, su sintaxis y su filosofía lo hacen fácil de leer y de aprender. Es cierto que no es tan legible como Python o Ruby, por ejemplo, pero es mucho más legible que otros lenguajes con características similares como C++ o Java.&lt;/p&gt;

&lt;h3 id=&quot;usable-para-los-programadores&quot;&gt;Usable para los programadores&lt;/h3&gt;

&lt;p&gt;Una de las promesas de Go desde el principio era poder hacer mucho con poco. Y es algo que cumple completamente. Su librería estándar está diseñada y construida por verdaderos titanes de la ingeniería del software, practicantes de esto por más tiempo que la vida de muchos de los que leerán este artículo. El siguiente ejemplo es un servidor web con una ruta, sin usar ningún framework o biblioteca extra, sino sólo la pura biblioteca estándar de Go.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;net/http&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandleFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HelloServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:8080&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HelloServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello, %s!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// te saluda de regreso&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;desventajas&quot;&gt;Desventajas&lt;/h2&gt;

&lt;h3 id=&quot;sistema-de-tipos&quot;&gt;Sistema de tipos&lt;/h3&gt;
&lt;p&gt;Esta no es una desventaja como tal de Go, sino una creada por el ecosistema de desarrollo actual: al haber tantos lenguajes que hacen manejo de valores y tipos de dato automáticamente, al programar en &lt;em&gt;cualquier&lt;/em&gt; lenguaje tipado, incluyendo Go, muchos sienten que están desperdiciando su tiempo.&lt;/p&gt;

&lt;h2 id=&quot;relativamente-joven&quot;&gt;Relativamente joven&lt;/h2&gt;

&lt;p&gt;Go tiene a penas 10 años de haber salido a la luz, 12 desde que se empezó a diseñar. El tiempo de vida de un lenguaje influye en su usabilidad y la conveniencia de varias formas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;La comunidad que ha desarrollado&lt;/li&gt;
  &lt;li&gt;Las herramientas disponibles&lt;/li&gt;
  &lt;li&gt;Los errores encontrados&lt;/li&gt;
  &lt;li&gt;Experiencias de otros desarrolladores con diferentes tipos y tamaños de sistemas&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Considera esto si tienes que hacer un proyecto grande.&lt;/p&gt;

&lt;h2 id=&quot;proyectos-que-lo-usan&quot;&gt;Proyectos que lo usan&lt;/h2&gt;

&lt;p&gt;Muchos proyectos importantes del mundo de la infraestructura, orquestación de servidores, contenedores, bases de datos y herramientas para programadores lo usan. Algunos ejemplos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Docker&lt;/li&gt;
  &lt;li&gt;Kubernetes&lt;/li&gt;
  &lt;li&gt;Terraform y Vault (casi todos las herramientas de HashiCorp)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.influxdata.com/&quot;&gt;InfluxDB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/caddyserver/caddy&quot;&gt;Caddy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Esto te debería dar una idea de la importancia de Go en el ecosistema de desarrollo. Grandes proyectos lo usan, grandes empresas lo usan.&lt;/p&gt;

&lt;h2 id=&quot;go-vs-rust&quot;&gt;Go vs Rust&lt;/h2&gt;

&lt;p&gt;Una discusión reciente es cuál de los dos lenguajes va a lograr efectivamente reemplazar a C, con características más modernas y como un lenguaje más adaptado a las necesidades actuales. Esto es pura opinión: Rust es un mejor candidato para reemplazar a C por sus características de manejo de memoria. Pero Rust no es un lenguaje tan fácil de aprender o empezar com Go.
En Go puedes hacer muchas cosas que haces con C razonablemente bien, sin tanta complicación y sin tener que manejar la memoria manualmente o semi-manualmente. La prueba está en todos los proyectos que manejan cosas de bajo nivel.&lt;/p&gt;

&lt;p&gt;Más adelante tendremos un artículo de por qué deberías aprender Rust.&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Go es un lenguaje relevante en 2019, 10 años después de haber nacido y lo seguirá siendo por muchos años, sobre todo por los proyectos ya desarrollados en él y las características de las que hablamos en este artículo. Aprenderlo te dará una herramienta más para desarrollar programas que valgan la pena y cumplan con lo esperado.&lt;/p&gt;

&lt;p&gt;Pero como &lt;a href=&quot;https://fs.blog/about/&quot;&gt;Shane Parrish&lt;/a&gt; dice: Go es “simple pero no fácil”. Es sencillo empezar a programar con él, pero dominar sus conceptos requiere estudio y esfuerzo. Go se siente como una herencia de gente muy sabia haciendo un lenguaje para hacer cosas grandes. No te arrepentirás de aprenderlo.&lt;/p&gt;</content><author><name>Héctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="go" /><category term="golang" /><category term="lenguajes-de-programación" /><summary type="html">Go es un lenguaje muy relevante en algunas áreas del desarrollo de software. Aprende para qué deberías usarlo y por qué te conviene aprenderlo.</summary></entry></feed>