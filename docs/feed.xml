<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://blog.thedojo.mx/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.thedojo.mx/" rel="alternate" type="text/html" /><updated>2019-12-20T13:57:55-06:00</updated><id>https://blog.thedojo.mx/feed.xml</id><author><name>H√©ctor Patricio</name><uri>https://github.com/hectorip</uri></author><entry><title type="html">Inducci√≥n y Deducci√≥n seg√∫n Polya</title><link href="https://blog.thedojo.mx/2019/12/14/induccion-y-deduccion-segun-polya.html" rel="alternate" type="text/html" title="Inducci√≥n y Deducci√≥n seg√∫n Polya" /><published>2019-12-14T00:00:00-06:00</published><updated>2019-12-14T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2019/12/14/induccion-y-deduccion-segun-polya</id><content type="html" xml:base="https://blog.thedojo.mx/2019/12/14/induccion-y-deduccion-segun-polya.html">&lt;p&gt;Este es el tercer art√≠culo acerca del libro &lt;a href=&quot;https://amzn.to/2P8HJA8&quot;&gt;‚ÄúHow to Solve It‚Äù&lt;/a&gt; de George Polya. Puedes ver los dos art√≠culos anteriores aqu√≠:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2019/09/27/tecnicas-para-resolver-problemas.html&quot;&gt;T√©cnicas para resolver problemas&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2019/10/03/el-arte-de-resolver-problemas-la-heuristica.html&quot;&gt;Heur√≠stica&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Con este art√≠culo cerraremos con las ideas que George Polya desarroll√≥ para resolver problemas.&lt;/p&gt;

&lt;h2 id=&quot;inducci√≥n-y-deducci√≥n&quot;&gt;Inducci√≥n y Deducci√≥n&lt;/h2&gt;

&lt;p&gt;Hablemos ahora de algunas formas de resolver problemas.&lt;/p&gt;

&lt;h3 id=&quot;deducci√≥n&quot;&gt;Deducci√≥n&lt;/h3&gt;

&lt;p&gt;Tratar de resolver problemas por deducci√≥n significa &lt;strong&gt;aplicar principios o
conocimiento general a un caso espec√≠fico&lt;/strong&gt;. Por ejemplo para un problema
pr√°ctico en el que tenemos encontrar la longitud de un cable tensor para una
antena, sabemos que podemos aplicar el teorema de Pit√°goras.&lt;/p&gt;

&lt;p&gt;Algunos ejemplos para los programadores:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Encontrar el elemento m√°s grande o m√°s peque√±o en una lista. (Una forma de resolverlo es ordenar los elementos).&lt;/li&gt;
  &lt;li&gt;Revisar que un elemento no est√° repetido en una colecci√≥n de elementos. (Indexado)&lt;/li&gt;
  &lt;li&gt;Asegurarse de que las operaciones son atendidas en el orden en que se solicitaron en un entorno con m√∫ltiples ejecutores. (Colas)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lo dif√≠cil de la deducci√≥n es encontrar &lt;em&gt;qu√© principios, teoremas o formas 
de resoluci√≥n de problemas aplican para el problema que tenemos que resolver&lt;/em&gt;. Para esto nos pueden ayudar las t√©cnicas platicadas en los art√≠culos anteriores: ¬øHe resuelto un problema similar? &lt;em&gt;¬øQu√© t√©cnica fue usada?&lt;/em&gt; ¬øQu√© principios sirvieron para la resoluci√≥n de ese problema? Y, a mi parecer la m√°s √∫til: ¬øpuedo usar el resultado o el proceso de resoluci√≥n?&lt;/p&gt;

&lt;!-- Polya dice que aunque se dice que Sherlock Holmes &quot;deduce&quot;, en realidad aplica la inducci√≥n para llegar a conclusiones, ya que aplica conocimiento general a casos concretos. --&gt;

&lt;h3 id=&quot;inducci√≥n&quot;&gt;Inducci√≥n&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;La inducci√≥n es el proceso de descubrir leyes generales mediante la observaci√≥n y combinaci√≥n de casos particulares. - &lt;em&gt;George Polya&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;La inducci√≥n es uno de los mecanismos de resoluci√≥n de problemas m√°s dif√≠ciles de llevar a la pr√°ctica. Funciona en forma inversa a la deducci√≥n.&lt;/p&gt;

&lt;p&gt;Consiste en partir de observaciones espec√≠ficas (ejemplos y contra-ejemplos) y llevarlas a &lt;strong&gt;generalizaciones&lt;/strong&gt; que puedan ser aplicadas en otros casos o que apliquen en muchas otras situaciones situaciones.&lt;/p&gt;

&lt;h3 id=&quot;en-el-desarrollo-de-software&quot;&gt;En el desarrollo de software&lt;/h3&gt;

&lt;p&gt;Seguro te has encontrado con este tipo problemas (o te vas a encontrar) si ya llevas tiempo desarrollando: ya que el desarrollo de software no es un √°rea que viva aislada de las dem√°s √°reas, los que requieren el software llevan &lt;em&gt;ejemplos&lt;/em&gt; de  problemas que regularmente tienen que resolver. Nuestros clientes, en general, no se han dado a la tarea de establecer las reglas por las que algo funciona de la manera en que lo hace, ni las excepciones ni los casos √∫nicos. Es nuestra tarea casi siempre descubrir las reglas que subyacen a las operaciones comunes. Esto es una forma de inducci√≥n.&lt;/p&gt;

&lt;h3 id=&quot;inducci√≥n-matem√°tica&quot;&gt;Inducci√≥n matem√°tica&lt;/h3&gt;

&lt;p&gt;Polya habla de otro tipo de inducci√≥n de la que opina que no deber√≠a llamarse as√≠, y que comparte muy poco con el proceso que acabamos de descubrir y puede llegar a confundir a la gente: la &lt;strong&gt;inducci√≥n matem√°tica&lt;/strong&gt;. Este tipo de inducci√≥n se refiere al m√©todo que los matem√°ticos emplean para demostrar que cierta aserci√≥n es un teorema o no.&lt;/p&gt;</content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="polya" /><category term="problem-solving" /><category term="how-to-solve-it" /><summary type="html">Aprende de los conceptos de inducci√≥n y deducci√≥n seg√∫n George Polya los explica en How to Solve It</summary></entry><entry><title type="html">Criptograf√≠a b√°sica para programadores: ¬øQu√© es la criptograf√≠a?</title><link href="https://blog.thedojo.mx/2019/11/12/criptografia-basica-para-programadores-que-es-la-criptografia.html" rel="alternate" type="text/html" title="Criptograf√≠a b√°sica para programadores: ¬øQu√© es la criptograf√≠a?" /><published>2019-11-12T00:00:00-06:00</published><updated>2019-11-12T00:00:00-06:00</updated><id>https://blog.thedojo.mx/2019/11/12/criptografia-basica-para-programadores-que-es-la-criptografia</id><content type="html" xml:base="https://blog.thedojo.mx/2019/11/12/criptografia-basica-para-programadores-que-es-la-criptografia.html">&lt;p&gt;Es muy com√∫n escuchar de ‚Äúencriptaci√≥n‚Äù (la palabra correcta en espa√±ol es &lt;em&gt;cifrado&lt;/em&gt;), llaves, algoritmos criptogr√°ficos y cosas parecidas, sobre todo con el surgimiento de Bitcoin y Blockchain.&lt;/p&gt;

&lt;p&gt;Uno de los temas menos tratados por programadores de software com√∫n (para usuarios y sistemas que no impliquen el uso de seguridad a medida), es el correcto uso de los algoritmos criptogr√°ficos y muchas veces ni siquiera conocemos lo suficiente de ellos, sino que confiamos en lo que las herramientas pre-establecen (que gran parte de las veces fue dise√±ado por expertos y eso est√° bien).&lt;/p&gt;

&lt;p&gt;Pero un poco de conocimiento sobre criptograf√≠a no te har√° da√±o, sobre todo si programas sistemas que necesiten seguridad (todos), y s√≠ puede evitarte errores fatales.&lt;/p&gt;

&lt;p&gt;Esta serie de art√≠culos tratar√° de todo lo que un programador debe saber acerca de la aplicaci√≥n correcta de algoritmos criptogr√°ficos a sus desarrollos, y un poco de su funcionamiento interno.&lt;/p&gt;

&lt;p&gt;Empecemos por lo m√°s b√°sico. ¬øQu√© es exactamente la criptograf√≠a?&lt;/p&gt;

&lt;h2 id=&quot;definici√≥n-de-criptograf√≠a&quot;&gt;Definici√≥n de Criptograf√≠a&lt;/h2&gt;

&lt;p&gt;La criptograf√≠a moderna se puede considerar una rama de las matem√°ticas (&lt;em&gt;otra vez&lt;/em&gt;) y la computaci√≥n enfocada en encontrar y crear formas de convertir informaci√≥n clara y con alg√∫n significado en &lt;em&gt;informaci√≥n imposible de entender por entidades que no cuenten con la autorizaci√≥n para hacerlo, aunque la tengan en su poder&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;La palabra quiere decir literalmente &lt;strong&gt;‚Äúescritura oculta‚Äù&lt;/strong&gt;. Y tambi√©n se puede definir el campo como el encargado de encontrar algoritmos o procedimientos que permitan ocultar mensajes que s√≥lo puedan ser descifrados por aquellos que tengan la llave.&lt;/p&gt;

&lt;p&gt;La criptograf√≠a implica &lt;em&gt;esconder&lt;/em&gt; informaci√≥n expl√≠citamente (los atacantes pueden saber que esa informaci√≥n est√° oculta e incluso hasta tener los mensajes ocultos en su poder), de manera que quien tenga la informaci√≥n correcta (que les concede la autorizaci√≥n) pueda obtener la informaci√≥n original desde los datos ininteligibles.&lt;/p&gt;

&lt;p&gt;Este proceso de ocultar la informaci√≥n se llama &lt;strong&gt;cifrado&lt;/strong&gt; (tambi√©n se usa &lt;em&gt;encriptado&lt;/em&gt;, como un barbarismo), mientras que el proceso de recuperar la informaci√≥n se llama &lt;strong&gt;descifrado&lt;/strong&gt; (o &lt;em&gt;desencriptado&lt;/em&gt; üôÑ).&lt;/p&gt;

&lt;p&gt;Los procesos de cifrado modernos requieren generalmente &lt;strong&gt;una llave o conjunto de llaves&lt;/strong&gt;, para realizar los procesos de cifrado y descifrado.&lt;/p&gt;

&lt;p&gt;La criptograf√≠a es la base de todos los mecanismos de seguridad inform√°tica modernos, y a menudo se usa una conbinaci√≥n de ellos para proteger un sistema.&lt;/p&gt;

&lt;h2 id=&quot;uso-en-el-software-actual&quot;&gt;Uso en el software actual&lt;/h2&gt;

&lt;p&gt;Los algoritmos criptogr√°ficos se usan en todos lados en los sistemas modernos. Son los algoritmos que permiten que la informaci√≥n viaje segura en internet (usando HTTPS, que se basa en TLS/SSL), por ejemplo. Algunos otros casos en los que son usados:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;En la protecci√≥n de la informaci√≥n que viaja en las redes inal√°mbricas, sean WiFi o Celulares (3G, 4G, 5G).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Almacenamiento de datos sensibles como passwords (mediante hash) e informaci√≥n personal (cifrados con password).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Protecci√≥n de archivos.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cifrado de datos en reposo (al estar almacenados en los discos duros) de los datos para evitar su robo en caso de robo f√≠sico o de dispositivos virtuales.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tarjetas de cr√©dito y seguridad bancaria en general.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Estos son tan s√≥lo algunos ejemplos de los lugares en los que la criptograf√≠a juega un papel &lt;strong&gt;muy importante&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;esteganograf√≠a&quot;&gt;Esteganograf√≠a&lt;/h3&gt;

&lt;p&gt;La esteganograf√≠a es la t√©cnica, relacionada con la criptograf√≠a, &lt;strong&gt;de hacer la informaci√≥n invisible&lt;/strong&gt;, generalmente ocult√°ndola dentro de otro tipo de informaci√≥n.&lt;/p&gt;

&lt;p&gt;Con t√©cnicas criptogr√°ficas comunes el que un atacante tenga disponible la informaci√≥n cifrada no hace necesariamente que nuestra informaci√≥n quede expuesta, a menos que el algoritmo criptogr√°fico sea d√©bil y el atacante tenga suficientes recursos para romperlo. En muchos casos incluso suponemos que los atacantes tienen acceso a esta informaci√≥n, como en el caso de la comunicaci√≥n en internet en la que en cualquier parte de la red puede haber alguien interceptando nuestra informaci√≥n.&lt;/p&gt;

&lt;p&gt;Las t√©cnicas esteganogr√°ficas buscan ‚Äúdesaparecer‚Äù completamente la informaci√≥n, hacerla invisible a trav√©s de ocultarla dentro de otros tipos de mensajes. En la antig√ºedad, por ejemplo en un libro que parec√≠a hablar de magia, se ocult√≥ un tratado acerca de criptograf√≠a y esteganograf√≠a, que s√≥lo fue revelado hasta que se encontr√≥ la llave correcta.&lt;/p&gt;

&lt;p&gt;Con la llegada de los medios digitales, en la que todo puede ser representado por medio de bits, en realidad se puede ocultar informaci√≥n de cualquier tipo en cualquier otro tipo de mensajes, pero tambi√©n se siguen usando medios f√≠sicos para ocultar informaci√≥n. Un ejemplo son los micro-puntos de algunas impresiones de manuscritos o informaci√≥n sensible repartido a personas de confianza que permiten identificar cada una de las copias entregadas a diferentes personas.&lt;/p&gt;

&lt;p&gt;Aunque la esteganograf√≠a y la criptograf√≠a son t√©cnicas relacionadas, la m√°s importante actualmente es la criptograf√≠a por su uso en la mayor√≠a de los sistemas inform√°ticos de la actualidad.&lt;/p&gt;

&lt;h2 id=&quot;por-qu√©-deber√≠as-aprender-criptograf√≠a&quot;&gt;¬øPor qu√© deber√≠as aprender criptograf√≠a?&lt;/h2&gt;

&lt;p&gt;Ya mencionamos lo importante que es en los sistemas actuales. La mayor√≠a de los lenguajes de programaci√≥n, los desarrollos open source, como los frameworks web, muchas librer√≠as, plataformas como servicio, etc. vienen con funciona de seguridad y criptogr√°ficas inclu√≠das. Pero no es suficiente con &lt;em&gt;ser usuario&lt;/em&gt; de estas cosas, ya que hasta los mecanismos y algoritmos mejor dise√±ados se pueden ser mal usados y minados por la mala utilizaci√≥n.&lt;/p&gt;

&lt;p&gt;Conocer temas como los siguientes, te permitir√° subir la calidad de tus desarrollos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¬øQu√© determina la seguridad de un algoritmo criptogr√°fico?&lt;/li&gt;
  &lt;li&gt;¬øPor qu√© es importante tener una llave de un tama√±o correcto?&lt;/li&gt;
  &lt;li&gt;¬øQu√© algoritmo debo escoger para esta caracter√≠stica que tengo que desarrollar?&lt;/li&gt;
  &lt;li&gt;¬øCu√°les son las principales caracter√≠sticas y diferencias de los algoritmos m√°s usados?&lt;/li&gt;
  &lt;li&gt;¬øQu√© algoritmos nunca m√°s deber√≠a usar en la vida?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;conclusi√≥n&quot;&gt;Conclusi√≥n&lt;/h2&gt;

&lt;p&gt;En este art√≠culo s√≥lo hemos tocado la definici√≥n de criptograf√≠a y hemos mencionado por qu√© es importante. En los siguientes empezaremos a hablar de las bases que nos permitir√°n comprender c√≥mo funciona la criptograf√≠a y qu√© mecanismos son los que permiten que brinde seguridad mediante ocultar la informaci√≥n.&lt;/p&gt;

&lt;p&gt;En el pr√≥ximo art√≠culo hablaremos de la base de todos los sistemas criptogr√°ficos. Los n√∫meros (pseudo) aleatorios y sus generadores.&lt;/p&gt;</content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="criptograf√≠a" /><category term="esteganograf√≠a" /><category term="seguridad" /><summary type="html">Aprende las bases de la criptograf√≠a para tenerla en cuenta en tus programas.</summary></entry><entry><title type="html">Entendiendo REST: Servicios cacheables</title><link href="https://blog.thedojo.mx/2019/10/27/entendiendo-rest-servicios-cacheables.html" rel="alternate" type="text/html" title="Entendiendo REST: Servicios cacheables" /><published>2019-10-27T00:00:00-05:00</published><updated>2019-10-27T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2019/10/27/entendiendo-rest-servicios-cacheables</id><content type="html" xml:base="https://blog.thedojo.mx/2019/10/27/entendiendo-rest-servicios-cacheables.html">&lt;p&gt;La tercera caracter√≠stica que &lt;a href=&quot;https://twitter.com/fielding&quot;&gt;Thomas R. Fielding&lt;/a&gt; (Roy Fielding a partir de ahora) establece para los sistemas &lt;strong&gt;REST&lt;/strong&gt; es la capacidad de que su informaci√≥n sea cacheable. Veamos lo que esto significa y por qu√© es una caracter√≠stica importante. Empecemos por definir el cach√©.&lt;/p&gt;

&lt;h2 id=&quot;qu√©-es-el-cach√©&quot;&gt;¬øQu√© es &lt;em&gt;el cach√©&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;Originalmente el cach√© se refiere a un tipo especial de memoria &lt;em&gt;muy r√°pida&lt;/em&gt; en los procesadores, que guarda &lt;em&gt;temporalmente&lt;/em&gt; informaci√≥n que tiene gran probabilidad de volver a ser utilizada &lt;em&gt;dentro de poco tiempo&lt;/em&gt; (en los procesadores hablamos de nano-segundos).&lt;/p&gt;

&lt;p&gt;Al evitar que el procesador vuelva a consultar la RAM (muy lenta en &lt;a href=&quot;https://gist.github.com/jboner/2841832&quot;&gt;comparaci√≥n con la memoria cach√©&lt;/a&gt;), las operaciones se realizan a mucha mayor velocidad.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/k0t1e.png&quot; alt=&quot;Latencia de diferentes tipos de memoria&quot; /&gt;&lt;/p&gt;

&lt;p&gt;La memoria cach√© de los procesadores tiene una gran desventaja: &lt;strong&gt;es muy muy peque√±a&lt;/strong&gt;. Esto presenta retos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¬øQu√© guardo aqu√≠ para maximizar la eficacia de este espacio de almacenamiento?&lt;/li&gt;
  &lt;li&gt;¬øC√≥mo decido cu√°ndo borrar o sobre-escribir la informaci√≥n que tengo aqu√≠?&lt;/li&gt;
  &lt;li&gt;¬øQu√© pasa si la informaci√≥n original cambia mientras estoy ocupando los datos guardados en la memoria cach√©?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hablaremos m√°s adelante de estas preguntas en nuestro propio contexto, pero hay t√©cnicas para poder contestarlas con cierta eficacia, que los &lt;a href=&quot;http://user.it.uu.se/~yi/pdf-files/2014/euc14.pdf&quot;&gt;procesadores han logrado implementar&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As√≠ que puedes pensar en el cach√© como en una memoria que es m√°s r√°pida (aunque m√°s limitada). Se utiliza con el objetivo de hacer un sistema m√°s r√°pido y a veces m√°s eficiente.&lt;/p&gt;

&lt;h2 id=&quot;cach√©-en-los-sistemas-rest&quot;&gt;Cach√© en los sistemas REST&lt;/h2&gt;

&lt;p&gt;Esta caracter√≠stica se basa en las dos que ya hablamos: &lt;a href=&quot;/2019/08/03/entendiendo-rest-servidor-sin-estado.html&quot;&gt;servicios sin estado&lt;/a&gt; y &lt;a href=&quot;/2019/07/04/entendiendo-rest-arquitectura-cliente-servidor.html&quot;&gt;arquitectura cliente-servidor&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lo que se define como ‚Äúcacheabilidad‚Äù en los sistemas REST es la capacidad
de estos sistemas para &lt;em&gt;etiquetar&lt;/em&gt; de alguna forma las respuestas para que
otros mecanismos intermedios funcionen como un cach√©.&lt;/p&gt;

&lt;p&gt;As√≠ el sistema puede atender m√°s peticiones, en menos tiempo, con menos
recursos (comparado con un sistema sin cach√©).&lt;/p&gt;

&lt;p&gt;Estos sistemas o mecanismos intermedios (existen entre el cliente y el servidor) deben ser por lo general transparentes para los desarrolladores,
no deben afectar la manera en que los servicios se consumen.&lt;/p&gt;

&lt;p&gt;En sistemas web que usan &lt;strong&gt;HTTP&lt;/strong&gt; para comunicarse el sistema de ‚Äúetiquetado‚Äù que permite que una respuesta sea cacheada son &lt;strong&gt;las cabeceras&lt;/strong&gt;. Estas permiten a los diferentes actores en el proceso de comunicaci√≥n (servidor local, proxy, proxy reverso, navegador o cliente final, entre otros), saber qui√©n deber√≠a cachear la informaci√≥n y por cu√°nto tiempo o c√≥mo decidir si deben renovar la informaci√≥n. Las cabeceras HTTP com√∫nmente usadas para esto son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Expires&lt;/code&gt;: especifica hasta cu√°ndo se puede considerar fresca o v√°lida la informaci√≥n.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-control&lt;/code&gt;: Es usado para especificar directivas de cach√© que deben ser respetadas por todos lo puntos por los que pasa la informaci√≥n. Puedes ver los posibles valores y su especifacaci√≥n aqu√≠: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.9&quot;&gt;Cache-Control Header&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vary&lt;/code&gt;: es usada para indicar qu√© otras cabeceras se deben tomar en cuenta para decidir si el servidor puede reutilizar una respuesta o no.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Etag&lt;/code&gt;: identifica a una respueste de manera √∫nica, puede usarse para pedir una respuesta nueva de un mismo endpoint, y en combinaci√≥n con la cabecera &lt;code class=&quot;highlighter-rouge&quot;&gt;If-None-Match&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Existen otras cabeceras usadas para lograr un control correcto del cach√© como &lt;code class=&quot;highlighter-rouge&quot;&gt;If-Modified-Since&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;ventajas-del-cach√©&quot;&gt;Ventajas del cach√©&lt;/h2&gt;

&lt;p&gt;El cach√© se establece como una de las caracter√≠sticas de REST porque proporciona ventajas para el uso y la escalabilidad de los sistemas. Veamos algunas de ellas.&lt;/p&gt;

&lt;h3 id=&quot;aumenta-la-percepci√≥n-de-velocidad&quot;&gt;Aumenta la percepci√≥n de velocidad&lt;/h3&gt;

&lt;p&gt;Al guardar las respuestas que es m√°s probable que vuelvan a salir, un sistema REST puede contestar una gran cantidad de sus peticiones a la velocidad que el cach√© lo permita, es decir, muy r√°pido.&lt;/p&gt;

&lt;h3 id=&quot;consumo-de-recursos-reducido&quot;&gt;Consumo de recursos reducido&lt;/h3&gt;

&lt;p&gt;El uso cach√© se parece mucho a una t√©cnica de programaci√≥n llamada &lt;strong&gt;dynamic programming&lt;/strong&gt; que consiste en guardar temporalmente los resultados de operaciones costosas en tiempo. Esto permite que
nos ahorremos el procesamiento de muchas respuestas que no se necesitan
de nuevo porque est√°n almacendas. Adem√°s se reduce el ancho de banda
consumido porque muchas peticiones ni siquiera tienen que llegar al servidor.&lt;/p&gt;

&lt;h3 id=&quot;sistemas-m√°s-f√°ciles-de-escalar&quot;&gt;Sistemas m√°s f√°ciles de escalar&lt;/h3&gt;

&lt;p&gt;Los sistemas que usan cach√© son capaces de aguantar m√°s peticiones
simult√°neas por la raz√≥n que vimos anteriormente: se reduce el consumo de recursos. Adem√°s, si se require crecer el sistema se deben poner menos recursos. Para algunos sistemas, el cach√© es lo √∫nico que tiene que crecer
cuando se requiere atender a m√°s usuarios simult√°neos.&lt;/p&gt;

&lt;h2 id=&quot;retos-de-cachear&quot;&gt;Retos de cachear&lt;/h2&gt;

&lt;p&gt;Toda soluci√≥n tecnol√≥gica implica ventajas y desventajas. Entonces ¬øqu√© desventajas o retos implica usar un sistema de cach√©?&lt;/p&gt;

&lt;h3 id=&quot;frescura&quot;&gt;Frescura&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;S√≥lo hay dos cosas dif√≠ciles en Ciencias de Computaci√≥n: invalidaci√≥n de cach√© y nombrar cosas. - Phil Karlton&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;El reto m√°s grande e importante de tener un sistema de cach√© es lograr un
equilibrio entre mantener la informaci√≥n el mayor tiempo posible y tener
informaci√≥n correcta y actualizada. Si se almacena en cach√© por demasiado
tiempo algo, esta informaci√≥n se vuelve vieja y por lo tanto puede estar desactualizada. Por el otro lado si se guarda por muy poco tiempo puede 
llevar a que los sistemas de cach√© se sub-utilicen y provean pocos
beneficios.&lt;/p&gt;

&lt;h3 id=&quot;dise√±o-del-sistema&quot;&gt;Dise√±o del sistema&lt;/h3&gt;

&lt;p&gt;Designar qu√© partes del sistema pueden ser cacheables y asignar los
etiquetados de las respuestas correctamente puede aumentar la complejidad del sistema en general.&lt;/p&gt;

&lt;h3 id=&quot;inconsistencia&quot;&gt;Inconsistencia&lt;/h3&gt;

&lt;p&gt;El uso de cach√© puede llevar a inconsistencias de informaci√≥n entre diferentes clientes por periodos de tiempo de diferente duraci√≥n. Esto es en parte consecuencia de la dificultad de mantener el cach√© fresco, pero adem√°s tiene que ver con la manera en que los clientes piden la informaci√≥n. &lt;strong&gt;Si tus clientes no pueden soportar la m√≠nima variaci√≥n en la informaci√≥n porque tendr√≠a consecuencias graves, es mejor no cachear.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusi√≥n&quot;&gt;Conclusi√≥n&lt;/h2&gt;

&lt;p&gt;El cach√© es una parte olvidada de los sistemas REST, el constraint menos mencionado. Pero es importante que les permite funcionar mejor cuando tenemos bastante carga. Mantenerlo funcionando bien es un reto, pero los sistemas que quieren ser escalables y resistentes deben implementar alguna forma de cachear.&lt;/p&gt;

&lt;p&gt;Roy Fielding menciona que es importante porque cualquier
sistema expuesto a clientes desconocidos tiene el peligro de recibir una
gran cantidad de carga s√∫bitamente, y si tu servicio no est√° preparado o es
f√°cil de escalar, fallar√°s.&lt;/p&gt;

&lt;p&gt;Si quieres leer un art√≠culo m√°s completo con otras referencias sobre el cach√© en REST y en HTTP te recomiendo &lt;a href=&quot;https://odino.org/rest-better-http-cache/&quot;&gt;REST better: HTTP Cache&lt;/a&gt;, en ingl√©s.&lt;/p&gt;

&lt;p&gt;En el siguiente art√≠culo veremos la cuarta restricci√≥n de los sistemas REST: la interfaz uniforme, la m√°s amplia de las restricciones, pero una de las m√°s √∫tiles.&lt;/p&gt;</content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><summary type="html">Los servicios REST deben ser cacheables, aprendamos lo que esto significa y c√≥mo podemos lograrlo.</summary></entry><entry><title type="html">El arte de resolver problemas: la heur√≠stica</title><link href="https://blog.thedojo.mx/2019/10/03/el-arte-de-resolver-problemas-la-heuristica.html" rel="alternate" type="text/html" title="El arte de resolver problemas: la heur√≠stica" /><published>2019-10-03T00:00:00-05:00</published><updated>2019-10-03T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2019/10/03/el-arte-de-resolver-problemas-la-heuristica</id><content type="html" xml:base="https://blog.thedojo.mx/2019/10/03/el-arte-de-resolver-problemas-la-heuristica.html">&lt;blockquote&gt;
  &lt;p&gt;La heur√≠stica habla del &lt;strong&gt;comportamiento humano&lt;/strong&gt; frente a los problemas. - George Polya&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;En un &lt;a href=&quot;/2019/09/27/tecnicas-para-resolver-problemas.html&quot;&gt;art√≠culo anterior&lt;/a&gt; analizamos la estructura b√°sica de un problema y la estructura de resoluci√≥n que George Polya propone para intentar resolverlos.&lt;/p&gt;

&lt;p&gt;Polya analiza a fondo la estructura del proceso de resoluci√≥n de problemas. Aqu√≠ hablaremos de &lt;strong&gt;la heur√≠stica&lt;/strong&gt;, de la que escribi√≥ en &lt;a href=&quot;https://math.hawaii.edu/home/pdf/putnam/PolyaHowToSolveIt.pdf&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;‚ÄúHow to solve it‚Äù&lt;/strong&gt;&lt;/a&gt;, un compendio que pens√≥ originalmente como un an√°lisis de esta.&lt;/p&gt;

&lt;h2 id=&quot;definici√≥n&quot;&gt;Definici√≥n&lt;/h2&gt;

&lt;p&gt;La palabra heur√≠stica viene de una ra√≠z griega que transmite la idea de &lt;strong&gt;descubrimiento o invenci√≥n&lt;/strong&gt;. La heur√≠stica hist√≥ricamente ha estado relacionada con &lt;strong&gt;estudiar los medios por los que se descubre o inventa algo&lt;/strong&gt;. Su campo de estudio abarca la l√≥gica, la psicolog√≠a y la filosof√≠a, pero no se puede acotar a ninguna de las tres √°reas.&lt;/p&gt;

&lt;p&gt;Polya estudia y define la heur√≠stica moderna como &lt;em&gt;el arte de resolver problemas&lt;/em&gt;, porque en eso consiste el proceso: descubrir una soluci√≥n(en los problemas en los que hay que &lt;em&gt;encontrar algo&lt;/em&gt;) o inventar algo (en los problemas en los que hay que &lt;em&gt;crear una demostraci√≥n&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Podemos echar mano de lo que nos ense√±a al atacar problemas muy dif√≠ciles de los que no tenemos la m√≠nima idea de c√≥mo resolver o no podemos idear un plan confiable para resolverlos (recuerda que crear un plan es el punto medular de la resoluci√≥n de un problema).&lt;/p&gt;

&lt;h2 id=&quot;heur√≠stica-moderna&quot;&gt;Heur√≠stica moderna&lt;/h2&gt;

&lt;p&gt;La heur√≠stica actualmente busca entender el proceso de resoluci√≥n de problemas, pero particularmente las operaciones mentales relacionadas con ese proceso.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;La experiencia en la resoluci√≥n de problemas u observar a otros resolver problemas debe ser la base de la heur√≠stica. - G. Polya&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Se busca encontrar patrones y propiedades comunes en una gran variedad de problemas, por lo que se puede decir que la heur√≠stica tiende a la generalidad, estudia procedimientos que son independientes del dominio del problema.
Polya habla de m√∫ltiples m√©todos y procedimientos para avanzar en la resoluci√≥n de un problema complicado.&lt;/p&gt;

&lt;p&gt;Analicemos algunos de ellos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Variaci√≥n del problema&lt;/strong&gt;. ¬øPuedo variar por lo menos temporalmente alguna de las partes del problema? ¬øPuedo cambiar los datos, las condiciones o la soluci√≥n?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Descomposici√≥n y recombinaci√≥n&lt;/strong&gt;. Esta operaci√≥n mental implica entender y separar las partes esenciales de un problema y tratar de re-crearlo con un nuevo entendimiento o crear un problema ligeramente diferente.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Regresar a las definiciones&lt;/strong&gt;. Comprender los t√©rminos usados en cada parte del problema a veces implicar√° que busquemos lo que algo significa desde sus ra√≠ces. Esto nos puede ayudar a entender mejor el problema as√≠ como a introducir elementos auxiliares que ayuden en la resoluci√≥n.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Generalizaci√≥n, especializaci√≥n y analog√≠as&lt;/strong&gt;. Estas tres operaciones son una forma de variar un problema. ¬øPuedo hacer el problema m√°s amplio, para resolver un caso m√°s general y despu√©s aplicar los resultados o el m√©todo a mi problema original? ¬øExiste un problema similar al que estoy resolviendo que pueda resolver m√°s f√°cilmente?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Notaci√≥n adecuada&lt;/strong&gt;. Una vez entendido el problema, sobre todo para problemas matem√°ticos, es muy importante introducir notaci√≥n que nos pueda ayudar a trabajar sobre el problema. Para los problemas matem√°ticos y en ciencias en general, ya existen estas notaciones est√°ndar. Para nuestros problemas tenemos que inventar una que la mayor√≠a de los implicados puede entender y usar.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Suponer, pero comprobar las suposiciones&lt;/strong&gt;. Para avanzar en la resoluci√≥n de un problema muchas veces hay que dar cosas por supuesto, como en el caso de las comprobaciones por reducci√≥n al absurdo. Polya afirma que no est√° mal suponer cosas temporalmente mientras m√°s adelante encontremos una forma de comprobar o rechazar esas suposiciones.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Trabajar en reversa&lt;/strong&gt;. Muchas veces sabemos &lt;em&gt;como luce&lt;/em&gt; la soluci√≥n, o tenemos que comprobar que una soluci√≥n supuesta es correcta. Trabajar en reversa significa avanzar de la soluci√≥n hasta nuestro estado actual, trabajando paso por paso hasta poder encontrar la cadena de transformaciones necesarias para conectar esos estados.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Aspectos psicol√≥gicos: determinaci√≥n, esperanza y √©xito&lt;/strong&gt;. Al principio mencionamos que la heur√≠stica es tambi√©n trataba con aspectos psicol√≥gicos. Polya afirma que ser√≠a un error considerar que los problemas son ejercicios puramente intelectuales. En el proceso de resoluci√≥n influye mucho los sentimientos y emocionses. Los tres puntos mencionados aqu√≠ son muy importantes para la resoluci√≥n de un problema. Primero, debemos &lt;em&gt;desear&lt;/em&gt; resolver el problema, esto es la determinaci√≥n. Segundo, debemos creer que somos &lt;em&gt;capaces&lt;/em&gt; de resolver el problema y que este tiene soluci√≥n. Y tercero, en lo relacionado con problemas intelectuales es muy dif√≠cil perseverar si no se experimenta una razonable dosis de √©xito de vez en cuando. Para esto es necesario aplicar algunas de las t√©cnicas mencionadas arriba.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Como puedes ver, la heur√≠stica es pr√°ctica. Adem√°s la heur√≠stica aplicada a la ense√±anza y a la puede tener efectos positivos, ya que ayuda a las personas a aprender a pensar mejor.&lt;/p&gt;

&lt;h2 id=&quot;razonamiento-heur√≠stico&quot;&gt;Razonamiento Heur√≠stico&lt;/h2&gt;

&lt;p&gt;Aplicar las t√©cnicas antes mencionadas tiene un efecto en la forma de resolver los problemas: en algunos de los pasos de la soluci√≥n aceptamos soluciones supuestas, incompletas, relacionadas vagamente con el problema o parcialmente err√≥neas con tal de avanzar en la soluci√≥n y el entendimiento del problema y de generar nuevas ideas/√©xitos para mantener y aumentar la motivaci√≥n.&lt;/p&gt;

&lt;p&gt;Esto no quiere decir que la heur√≠stica acepte soluciones err√≥neas, estos pasos son temporales, y las soluciones finales deben ser comprobadas con el mayor rigor posible.&lt;/p&gt;

&lt;h2 id=&quot;algoritmos-heur√≠sticos&quot;&gt;Algoritmos heur√≠sticos&lt;/h2&gt;

&lt;p&gt;Ahora hablemos de aprovechar estas ideas para la programaci√≥n, con una clase de algoritmos conocidos como algoritmos heur√≠sticos.&lt;/p&gt;

&lt;p&gt;Un algoritmo heur√≠stico en vez de garantizar siempre la mejor soluci√≥n en cada paso del programa, acepta soluciones parciales o suficientemente buenas. Este tipo de algoritmos funciona muy bien en casos donde hay demasiadas soluciones posibles como para probarlas todas (fuerza bruta) o muchas de ellas (como los algoritmos de &lt;em&gt;backtracking&lt;/em&gt;) y no hay ning√∫n algoritmo establecido conocido que resuleva el problema  o se haya demostrado que esta soluci√≥n es imposible.&lt;/p&gt;

&lt;p&gt;La principal diferencia a tener en cuenta cuando hablamos o tratamos con este tipo de algoritmos es que &lt;strong&gt;no garantizan la respuesta correcta o la respuesta √≥ptima&lt;/strong&gt;, aunque en algunos casos son la mejor forma de lograrlo. Fuera de la programaci√≥n, la heur√≠stica nos ayuda a llegar a la respuesta correcta aceptando temporalmente soluciones intermedias no √≥ptimas, semi-err√≥neas o incompletas, pero con soluciones finales &lt;em&gt;*que se pueden verificar como correctas rigurosamente&lt;/em&gt;. No es as√≠ con los algoritmos heur√≠sticos en la programaci√≥n, y he aqu√≠ por lo que el nombre puede confundirnos.&lt;/p&gt;

&lt;h2 id=&quot;conclusi√≥n&quot;&gt;Conclusi√≥n&lt;/h2&gt;

&lt;p&gt;La heur√≠stica es un campo de estudio valioso sobre todo para la vida moderna y para el desarrollo de software porque puede ayudarnos a estructurar nuestros esfuerzos en la resoluci√≥n de los problemas que nos enfrentamos.&lt;/p&gt;

&lt;p&gt;En el siguiente y √∫ltimo art√≠culo de la serie analizaremos m√°s t√©cnicas usadas en la resoluci√≥n de problemas de las que Polya habla en el libro ‚ÄúHow to Solve It‚Äù.&lt;/p&gt;</content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="polya" /><category term="problemas" /><category term="how_to_solve_it" /><category term="heur√≠stica" /><category term="heuristics" /><summary type="html">La heur√≠stica te ayudar√° a resolver mejor los problemas que se te presentan como programador. Veamosla m√°s detenidamente.</summary></entry><entry><title type="html">T√©cnicas para resolver problemas</title><link href="https://blog.thedojo.mx/2019/09/27/tecnicas-para-resolver-problemas.html" rel="alternate" type="text/html" title="T√©cnicas para resolver problemas" /><published>2019-09-27T00:00:00-05:00</published><updated>2019-09-27T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2019/09/27/tecnicas-para-resolver-problemas</id><content type="html" xml:base="https://blog.thedojo.mx/2019/09/27/tecnicas-para-resolver-problemas.html">&lt;p&gt;Todos los desarrolladores nos hemos encontrado con problemas que nos dejan perplejos y que no tenemos idea de por d√≥nde empezar a resolver.&lt;/p&gt;

&lt;p&gt;George Polya fue uno de los matem√°ticos m√°s prol√≠ficos del Siglo XX, un matem√°tico de primera clase (de esos que descubren e inventan cosas, y para algunos, &lt;strong&gt;el matem√°tico m√°s influyente del siglo&lt;/strong&gt;) pero que, a diferencia de muchos otros, manten√≠a un inter√©s por la educaci√≥n y la ense√±anza de las matem√°ticas, algo muy peculiar.&lt;/p&gt;

&lt;p&gt;Escribi√≥ varios libros, entre ellos est√° &lt;strong&gt;‚ÄúHow to solve it‚Äù&lt;/strong&gt; un tratado de 4 partes en el que explica de manera muy detallada c√≥mo resolver problemas matem√°ticos principalmente, pero tambi√©n c√≥mo aplicar este conocimiento a otras √°reas de la vida.&lt;/p&gt;

&lt;p&gt;Las t√©cnicas explicadas por Polya te pueden ayudar a desarrollar tus capacidades de resoluci√≥n de problemas.&lt;/p&gt;

&lt;p&gt;Empecemos por hablar de la estructura los problemas de los que Polya habla en su libro.&lt;/p&gt;

&lt;h2 id=&quot;estructura-de-un-problema&quot;&gt;Estructura de un problema&lt;/h2&gt;

&lt;p&gt;Polya ense√±a que un problema tiene tres partes:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Los datos&lt;/strong&gt;. Es la informaci√≥n que tenemos disponible para resolver el problema.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Las condiciones&lt;/strong&gt;. Describen la relaci√≥n que existe entre los datos y la soluci√≥n, pero tambi√©n la forma, los l√≠mites y caracter√≠sticas de la soluci√≥n buscada.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;La inc√≥gnita o lo desconocido&lt;/strong&gt;. Es la informaci√≥n que buscamos y que cumple con las condiciones del problema.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Es muy importante conocer la composici√≥n de un problema para poder aplicar las t√©cnicas descritas en el libro. Cualquier problema matem√°tico &lt;strong&gt;deber√≠a cumplir con estas caracter√≠sticas&lt;/strong&gt;, pero no todos los problemas de la vida real cumplen con esta estructura tal y como la necesitamos; por esta raz√≥n deber√≠amos desarrollar la capacidad de entender los problemas que se nos presentan y estructurarlos lo mejor posible seg√∫n esta definici√≥n para facilitarnos la vida posteriormente.&lt;/p&gt;

&lt;p&gt;Para resolver un problema deber√≠as ser capaz de contestar las siguientes preguntas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¬øQu√© estoy buscando? -&amp;gt; &lt;strong&gt;¬øCu√°l es la inc√≥gnita?&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;¬øQu√© datos tengo disponibles? -&amp;gt; &lt;strong&gt;¬øSon suficientes los datos que tengo para resolver el problema?&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;¬øQu√© condiciones tiene que cumplir la inc√≥gnita? -&amp;gt; &lt;strong&gt;¬øEs posible cumplir con esta condici√≥n?&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;¬øQu√© relaci√≥n hay entre los datos y la inc√≥gnita?&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Esta estructura sienta las bases para lo que viene. Ahora hablemos de de los tipos de problemas de los que Polya hace distinci√≥n.&lt;/p&gt;

&lt;h2 id=&quot;tipos-de-problemas&quot;&gt;Tipos de problemas&lt;/h2&gt;

&lt;p&gt;Polya hace la distinci√≥n entre dos tipos diferentes de problemas que hay que tratar de resolver de manera ligeramente diferente aunque la estructura sea la misma.&lt;/p&gt;

&lt;h3 id=&quot;1-problemas-para-encontrar&quot;&gt;1. Problemas para encontrar&lt;/h3&gt;

&lt;p&gt;Estos son los problemas b√°sicos que nos pon√≠an en la escuela primaria: ‚Äú&lt;strong&gt;Hallar&lt;/strong&gt; el √°rea de un terreno cuadrado de 10m por lado‚Äù, ‚Äú&lt;strong&gt;Encuentra&lt;/strong&gt; la di√°metro de una circunferencia con un per√≠metro de 12cm‚Äù.&lt;/p&gt;

&lt;p&gt;En este tipo de problemas hay que encontrar un resultado, que puede ser num√©rico o no. Estos son los problemas con los que nos encontramos mayormente en √°reas del conocimiento muy exploradas.&lt;/p&gt;

&lt;p&gt;Como programadores podr√≠amos tener estos ejemplos de este tipo de problemas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¬øQu√© complejidad tiene este algoritmo que acabo de programar?&lt;/li&gt;
  &lt;li&gt;¬øA cu√°ntos usuarios simult√°neos podr√© atender con este servidor con 4GB de RAM?&lt;/li&gt;
  &lt;li&gt;¬øCu√°nto tiempo va a tardar en subir mi mill√≥n de archivos si lo vuelvo paralelo? ¬øCu√°nto va a tardar si no lo paralelizo?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Varios de estos problemas suenan demasiado simples porque ya los tenemos bien trabajados a base de repetici√≥n. Pero otros que no tienen una respuesta num√©rica pueden ser un poco m√°s complicados:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¬øQu√© base de datos deber√≠a usar para servir notificaciones en tiempo real?&lt;/li&gt;
  &lt;li&gt;¬øQu√© lenguaje de programaci√≥n debo usar para un sistema que estar√° emebebido en un mill√≥n de dispositivos electr√≥nicos mandando notificaciones cr√≠ticas cada segundo?&lt;/li&gt;
  &lt;li&gt;¬øQu√© sistema de comunicaci√≥n puedo usar entre dos dispositivos que no cuentan con una conexi√≥n confiable a internet?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En los ejemplos anteriores encontrar una soluci√≥n concreta a las preguntas planteadas permite avanzar.&lt;/p&gt;

&lt;h3 id=&quot;2-problemas-para-demostrar&quot;&gt;2. Problemas para demostrar&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;‚ÄúDemuestre que la l√≠nea de mayor longitud que toca dos puntos de una circunferencia pasa por el centro del c√≠rculo‚Äù.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Esto es un ejemplo de un problema para demostrar. Estos implican la comprobaci√≥n o refutaci√≥n de una aserci√≥n (&lt;em&gt;hip√≥tesis&lt;/em&gt;) enunciada en el problema. Estos problemas generalmente nos los pon√≠an en la preparatoria o universidad, por su naturaleza son un poco m√°s dif√≠ciles en general.&lt;/p&gt;

&lt;p&gt;Para un desarrollador podr√≠amos poner problemas para demostrar como:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;‚ÄúDemuestra que es imposible un bloqueo mutuo entre procesos con el algoritmo usado actualmente‚Äù.&lt;/li&gt;
  &lt;li&gt;‚Äú¬øC√≥mo sabemos que evitamos todas las condiciones de carrera en el sistema actual?‚Äù&lt;/li&gt;
  &lt;li&gt;‚ÄúComprueba que el m√°ximo tiempo que puede tardar el sistema en responder es menor que X.‚Äù&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Estos problemas requieren soluciones m√°s generales y abstractas en general. Espero que con estos ejemplos haya quedado clara la diferencia entre los diferentes tipos de problemas.&lt;/p&gt;

&lt;h3 id=&quot;problemas-matem√°ticos-acertijos-y-problemas-de-la-vida-real&quot;&gt;Problemas matem√°ticos, acertijos y problemas de la vida real&lt;/h3&gt;

&lt;p&gt;Polya habla en sus libro sobre todo de un tipo espec√≠fico de problemas: &lt;strong&gt;los problemas matem√°ticos&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Un problema matem√°tico bien definido cuenta con:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Datos suficientes para resoluci√≥n&lt;/li&gt;
  &lt;li&gt;No tiene datos sobrantes&lt;/li&gt;
  &lt;li&gt;Condiciones no contradictorias o imposibles de cumplir&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Por extensi√≥n, &lt;strong&gt;los acertijos&lt;/strong&gt; cumplen con las mismas caracter√≠sticas, y se dan algunos de ejemplos de ellos en el libro.
Pero los problemas de la vida real son muy diferentes, ya que estos pueden no cumplir con las caracter√≠sticas completas
de un problema bien definido. As√≠ que uno de los pasos previos para resolver un problema de la vida real es intentar definir lo mejor posible el problema por resolver y completarlo en caso de que falte algo.&lt;/p&gt;

&lt;h2 id=&quot;c√≥mo-empezar-a-resolver-un-problema&quot;&gt;C√≥mo empezar a resolver un problema&lt;/h2&gt;
&lt;p&gt;Polya plantea cuatro etapas de resoluci√≥n de un problema:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Entendimiento&lt;/li&gt;
  &lt;li&gt;Planeaci√≥n&lt;/li&gt;
  &lt;li&gt;Ejecuci√≥n&lt;/li&gt;
  &lt;li&gt;Retrospectiva&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hablemos de cada una, para entender claramente c√≥mo podemos mejorar nuestras posibilidades de resoluci√≥n de un problema.&lt;/p&gt;

&lt;h3 id=&quot;entendimiento&quot;&gt;Entendimiento&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Es tonto contestar una pregunta que no entiendes. Es triste trabajar por un fin que no deseas. - &lt;strong&gt;G. Polya&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;El entendimiento del problema consiste primero en asegurarnos de que &lt;strong&gt;entendemos el planteamiento verbal del problema&lt;/strong&gt;, si no tenemos ni siquiera un planteamiento verbal, debemos empezar por crearlo.&lt;/p&gt;

&lt;p&gt;Para decir que comprendemos el problema, tenemos que conocer los datos que se dan, las condiciones a satisfacer y la inc√≥gnita o lo que hay que demostrar.&lt;/p&gt;

&lt;p&gt;Esta parte puede llevar gran parte del tiempo total dedicado al problema, ya que es el fundamento de los pr√≥ximos pasos, sin la que no se puede continuar.&lt;/p&gt;

&lt;p&gt;### Planeaci√≥n&lt;/p&gt;

&lt;p&gt;El siguiente paso es trazar un plan para atacar el problema. El plan consiste en saber que transformaciones, derivaciones y combinaciones tenemos que hacer con los datos para llegar a la soluci√≥n esperada.&lt;/p&gt;

&lt;p&gt;Esta es la parte m√°s dif√≠cil, ya que implica conocimiento profundo del problema. Para Polya, concebir un plan es el mayor logro en la resoluci√≥n de un problema. Cuando lo concebimos parece que tenemos una ‚Äúidea brillante‚Äù.&lt;/p&gt;

&lt;p&gt;Pero es casi imposible tener una idea brillante cuando sabemos muy poco del tema. Las buenas ideas est√°n basadas en conocimiento y experiencia previa. Por eso conviene preguntarse: &lt;strong&gt;¬øConozco o resuelto un problema relacionado o similar?&lt;/strong&gt;. Hablaremos de otras preguntas que nos pueden ayudar a concebir un plan m√°s adelante.&lt;/p&gt;

&lt;p&gt;### Ejecuci√≥n&lt;/p&gt;

&lt;p&gt;Es hora de llevar a cabo los pasos establecidos en la planeaci√≥n. En esta etapa hay que ejecutar cada uno de los pasos que establecimos en la planeaci√≥n de ejecuci√≥n del problema. Polya dice que aqu√≠ es donde &lt;strong&gt;hay que ser rigurosos con lo que hacemos&lt;/strong&gt;, verificando que lo que hacemos tenga sentido y sea estrictamente correcto. ¬øPuedes comprobar en cada paso que es correcto lo que est√°s haciendo?&lt;/p&gt;

&lt;p&gt;### Retrospectiva&lt;/p&gt;

&lt;p&gt;En este paso hay que &lt;strong&gt;examinar el resultado&lt;/strong&gt;. ¬øPuedes probar que el resultado final es correcto?
Adem√°s podemos ver si podemos hacer algo diferente, si nuestro resultado cumple con todo lo esperado y si podemos encontrar o derivar el resultado de alguna otra forma ahora que ya sabemos cu√°l es.&lt;/p&gt;

&lt;p&gt;Este paso tambi√©n sirve para verificar si el resultado o el m√©todo que usamos para resolverlo nues puede ayudar con alg√∫n otro problema que tengamos que resolver.&lt;/p&gt;

&lt;h3 id=&quot;las-preguntas-de-polya&quot;&gt;Las preguntas de Polya&lt;/h3&gt;

&lt;p&gt;Polya estableci√≥ una serie de preguntas que pueden guiarte en la soluci√≥n de un problema, muy relacionadas con los pasos de los que acabamos de hablar. Estas preguntas las repite vez tras vez en el libro y en verdad son iluminadoras si est√°s atorado en alg√∫n problema que no puedes resolver. A continuaci√≥n las listamos.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¬øHe resuelto un problema &lt;strong&gt;relacionado&lt;/strong&gt;? ¬øConozco un &lt;strong&gt;problema que se aproxime&lt;/strong&gt;?&lt;/li&gt;
  &lt;li&gt;¬øEstoy usando todos los datos?&lt;/li&gt;
  &lt;li&gt;¬øPuedo cambiar algo del problema para hacerlo m√°s f√°cil?
    &lt;ul&gt;
      &lt;li&gt;¬øPuedo cambiar los datos?&lt;/li&gt;
      &lt;li&gt;¬øPuedo cambiar las condiciones?&lt;/li&gt;
      &lt;li&gt;¬øPuedo cambiar la inc√≥gnita?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;para-recordar&quot;&gt;Para recordar&lt;/h2&gt;

&lt;p&gt;Para resolver un problema:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Aseg√∫rate de entender el problema completamente: qu√© datos tienes, qu√© relaci√≥n hay entre los datos y la inc√≥gnita y lo que tienes que encontrar.&lt;/li&gt;
  &lt;li&gt;Planea c√≥mo vas a atacar el problema&lt;/li&gt;
  &lt;li&gt;Si est√°s detenido en la resoluci√≥n de un problema puedes:
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Variar los datos&lt;/strong&gt;, las condiciones o el resultado esperado.&lt;/li&gt;
      &lt;li&gt;Pensar en otros problemas que se le parezcan: puedes usar el m√©todo que usaste para resolverlos o el resultado.&lt;/li&gt;
      &lt;li&gt;Aceptar soluciones parciales, parcialmente err√≥neas o asumidas.&lt;/li&gt;
      &lt;li&gt;Genera nuevas ideas y re-eval√∫a el problema y el plan a la luz de cada nuevo paso.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Aprovecha cualquier idea aunque suene disparatada.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En el siguiente post hablaremos de 5 cosas m√°s de las que Polya habla en su libro: heur√≠stica, inducci√≥n, deducci√≥n, an√°lisis y s√≠ntesis.&lt;/p&gt;</content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="matem√°ticas" /><category term="maths" /><category term="polya" /><category term="books" /><category term="libros" /><summary type="html">¬øCu√°ntas veces te has enfrentado a problemas de los que no tienes ni idea de c√≥mo empezar a resolver? George Polya escribi√≥ un libro completo sobre eso en 1928. Hablemos de las principales lecciones que podemos sacar.</summary></entry><entry><title type="html">¬øPor qu√© deber√≠as aprender Go?</title><link href="https://blog.thedojo.mx/2019/09/01/por-que-deberias-aprender-go.html" rel="alternate" type="text/html" title="¬øPor qu√© deber√≠as aprender Go?" /><published>2019-09-01T00:00:00-05:00</published><updated>2019-09-01T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2019/09/01/por-que-deberias-aprender-go</id><content type="html" xml:base="https://blog.thedojo.mx/2019/09/01/por-que-deberias-aprender-go.html">&lt;blockquote&gt;
  &lt;p&gt;Go es &lt;strong&gt;eficiente, escalable y productivo&lt;/strong&gt;. - &lt;em&gt;Rob Pike&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Go es un lenguaje que llama la atenci√≥n por algunos rumores que hay acerca de √©l, como, por ejemplo, que es el lenguaje que va a matar a C, o que es muy muy r√°pido y poderoso. En este art√≠culo vamos a hablar de qu√© cosas son ciertas y en qu√© casos te conviene aprender Go.&lt;/p&gt;

&lt;p&gt;Empecemos hablando de c√≥mo y por qu√© naci√≥.&lt;/p&gt;

&lt;h2 id=&quot;historia-de-go&quot;&gt;Historia de Go&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Go fue dise√±ado por Google para resolver sus problemas, y Google tiene &lt;em&gt;grandes&lt;/em&gt; problemas. - &lt;em&gt;Rob Pike&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Go fue creado dentro de Google por un grupo de desarrolladores de software y cient√≠ficos de la computaci√≥n &lt;strong&gt;MUY experimentados&lt;/strong&gt;. Las tres personas que lo iniciaron a pensar y dise√±ar en 2007 fueron Robert Griesemer, Rob Pike y &lt;strong&gt;Ken Thompson&lt;/strong&gt; (s√≠, el co-creador de UNIX, grep y muchas cosas m√°s). De ese tama√±o son las personas que lo dise√±aron, y as√≠ se siente el lenguaje cuando lo usas.&lt;/p&gt;

&lt;p&gt;Despu√©s de una serie de correos y discusiones sobre el dise√±o, empezaron a trabajar en √©l y &lt;a href=&quot;https://www.youtube.com/watch?v=rKnDgT73v8s&quot;&gt;lo presentaron como proyecto Open Source en 2009&lt;/a&gt;, a partir de ah√≠ muchas personas tanto de dentro como de fuera de Google han contribuido a su desarrollo.&lt;/p&gt;

&lt;h2 id=&quot;caracter√≠sticas-de--go&quot;&gt;Caracter√≠sticas de  Go&lt;/h2&gt;

&lt;p&gt;Go fue concebido pensando en los problemas que los dise√±adores ve√≠an en los sistemas de Google: su proceso de desarrollo estaba entorpecido por las herramientas que usaban. Seg√∫n Rob Pike, todo era demasiado lento: demasiado lento de compilar, demasiado lento de construir, demasiado lento de pensar. Cuando decimos que el tiempo de compilaci√≥n era demasiado largo nos referimos a que pod√≠a llegar a tomar &lt;em&gt;varias horas&lt;/em&gt; para compilar un sistema.&lt;/p&gt;

&lt;p&gt;Tambi√©n hab√≠a una ‚Äúexplosi√≥n de complejidad‚Äù. As√≠ que Go fue pensado para ser simple, de una ‚Äúsimplicidad radical‚Äù. Por lo tanto, carece de caracter√≠sticas que otros lenguajes s√≠ tienen, pero hacen que los programas sean complejos.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;La simplicidad es la clave del buen software. - &lt;em&gt;The Go Programming Language&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Analicemos las caracter√≠sticas de Go, un lenguaje pensado para trabajar en sistemas muy grandes de manera simple.&lt;/p&gt;

&lt;h3 id=&quot;procedural-con-flexibilidad-para-orientaci√≥n-a-objetos&quot;&gt;Procedural, con flexibilidad para orientaci√≥n a objetos&lt;/h3&gt;

&lt;p&gt;El paradigma principal de Go es el procedural se parece mucho a C en este aspecto. Sus principales medios de organizaci√≥n son las funciones y los paquetes, aunque permite crear un tipo d√©bil de organizaci√≥n muy parecida a los objetos mediante &lt;code class=&quot;highlighter-rouge&quot;&gt;structs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Aqu√≠ puedes ver un ‚ÄòHello world‚Äô:&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;¬°Hola Go!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;tipado-est√°tico-y-fuerte&quot;&gt;Tipado est√°tico y fuerte&lt;/h3&gt;

&lt;p&gt;Go es un lenguaje fuertemente tipado, lo cu√°l quiere implica varias cosas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;La declaraci√≥n de variables implica el tipo de valor que estar√° asociado a esta instancia del nombre, por lo que no puede usarse para guardar otro tipo de valor. En Go no necesariamente se tiene que decir expl√≠citamente el tipo de valor a usarse, puede ser inferido:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;n&quot;&gt;miNombre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;H√©ctor&quot;&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// La variable es un string&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Esto es verificado en tiempo de compilaci√≥n, por lo que podr√°s estar tranquilo de que Go no te dejar√° correr programas usando variables como lo que no son.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;No existe la conversi√≥n o forzamiento de tipos autom√°tica e impl√≠cita, como en JS, que intenta realizar la operaci√≥n aunque los tipos de valor usados no tengan sentido en la operaci√≥n. En Go, si intentas hacer una operaci√≥n con tipos no compatibles el programa puede no compilar o fallar en tiempo de ejecuci√≥n.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;r√°pida-compilaci√≥n&quot;&gt;R√°pida compilaci√≥n&lt;/h3&gt;

&lt;p&gt;Pensado para sistemas muy grandes, justo como los desarrollados en Google, Go se toma en serio el tiempo de complicaci√≥n y es muy r√°pido al compilar los programas, a diferencia de Java, C o C++. Esto est√° apoyado por tres pilares:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Las dependencias est√°n puestas al principio de cada archivo, por lo que no hay que buscar en todo el programa por dependencias perdidas.&lt;/li&gt;
  &lt;li&gt;Las dependencias no forman ciclos, por lo que pueden organizarse para que sean compiladas independientemente, incluso de manera paralela.&lt;/li&gt;
  &lt;li&gt;El programa objeto compilado de cada paquete exporta informaci√≥n √∫til para sus dependencias que puede ser usada sin tener que leer todo el paquete.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;manejo-de-dependencias-y-paquetes&quot;&gt;Manejo de dependencias y paquetes&lt;/h3&gt;
&lt;p&gt;Go tiene en su biblioteca est√°ndar m√°s de 100 paquetes y la comunidad de Go cada vez contribuye m√°s paquetes. Go viene con la herramienta para la l√≠nea de comandos &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt; que es f√°cil de usar para manejar proyectos creados con Go. La herramienta &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt; nos ayuda a administrar nuestras dependencias: descargarlas, limpiarlas e instalarlas.&lt;/p&gt;

&lt;h3 id=&quot;manejo-de-memoria&quot;&gt;Manejo de memoria&lt;/h3&gt;
&lt;p&gt;Go tiene manejo autom√°tico de memoria, lo que quiere decir que tal como en Java o Python, no tienes que preocuparte de liberar la memoria manualmente. Sin embargo, esta caracter√≠stica lo hace poco pr√°ctico para sistemas que requieran tratamiento de datos en tiempo real demasiado fuerte y preciso.&lt;/p&gt;

&lt;h2 id=&quot;concurrencia&quot;&gt;Concurrencia&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/v1567320490/Go-routines-gopher_vgcpbt.jpg&quot; alt=&quot;La mascota de Go haciendo el trabajo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A esta caracter√≠stica decidimos dedicarle un poco m√°s de espacio. Debido a que el mundo de la computaci√≥n ha cambiado desde que se escribieron los primeros programas, en los que se contaba con un s√≥lo procesador, el equipo de Go le dio gran importancia a la capacidad de &lt;strong&gt;crear programas con un muy buen dise√±o concurrente&lt;/strong&gt;. Eventualmente estos programas podr√≠an correr en paralelo aprovechando los sistemas de computaci√≥n que existen actualmente, con m√∫ltiples procesadores.&lt;/p&gt;

&lt;p&gt;Go permite crear procesos concurrente de manera muy sencilla:&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Eso es todo. Go ejecutar√° la funci√≥n &lt;code class=&quot;highlighter-rouge&quot;&gt;myFunc&lt;/code&gt; de manera concurrente (se ejecuta de manera independiente al programa principal o a otras funciones concurrentes). Esto es una &lt;strong&gt;gorutine&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Go soporta dos modelos de concurrencia:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Comunicaci√≥n de procesos secuenciales&lt;/strong&gt; (Communicating Sequential Processes - CSP), en la que cada proceso tiene sus propias variables, y se transfieren informaci√≥n entre ellos mediante mensajes. En el caso de Go es a trav√©s de &lt;em&gt;canales&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Multihilo con memoria compartida&lt;/strong&gt;. En este tipo de concurrencia todos los procesos escriben sobre el mismo espacio de memoria, es decir, comparten variables, pero debe haber alg√∫na forma de coordinaci√≥n entre ellos para que no choquen ni se bloqueen mutuamente al tomar un recurso.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La concurrencia es uno de los puntos m√°s fuertes de Go.&lt;/p&gt;

&lt;h2 id=&quot;ventajas-de-go-sobre-otros-lenguajes&quot;&gt;Ventajas de Go sobre otros lenguajes&lt;/h2&gt;

&lt;p&gt;Hablemos de en qu√© casos querr√≠as usar Go.&lt;/p&gt;

&lt;h3 id=&quot;eficiencia-al-correr&quot;&gt;Eficiencia al correr&lt;/h3&gt;
&lt;p&gt;Go no corre sobre ninguna m√°quina virtual. Crea ejecutables para los sistemas operativos a los que apunta, que contienen todo lo necesario para poder ejecutarse sin necesidad de tener algo instalado all√≠. Al ser compilado, Go es mucho m√°s eficiente para correr que otros lenguajes interpretados, como JS, Python o Ruby. Consume menos memoria y su velocidad se acerca a la de C.&lt;/p&gt;

&lt;h3 id=&quot;legibilidad&quot;&gt;Legibilidad&lt;/h3&gt;
&lt;p&gt;Go fue pensado para ser &lt;em&gt;simple&lt;/em&gt;. Sus estructuras, su sintaxis y su filosof√≠a lo hacen f√°cil de leer y de aprender. Es cierto que no es tan legible como Python o Ruby, por ejemplo, pero es mucho m√°s legible que otros lenguajes con caracter√≠sticas similares como C++ o Java.&lt;/p&gt;

&lt;h3 id=&quot;usable-para-los-programadores&quot;&gt;Usable para los programadores&lt;/h3&gt;

&lt;p&gt;Una de las promesas de Go desde el principio era poder hacer mucho con poco. Y es algo que cumple completamente. Su librer√≠a est√°ndar est√° dise√±ada y construida por verdaderos titanes de la ingenier√≠a del software, practicantes de esto por m√°s tiempo que la vida de muchos de los que leer√°n este art√≠culo. El siguiente ejemplo es un servidor web con una ruta, sin usar ning√∫n framework o biblioteca extra, sino s√≥lo la pura biblioteca est√°ndar de Go.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;net/http&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandleFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HelloServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:8080&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HelloServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello, %s!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// te saluda de regreso&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;desventajas&quot;&gt;Desventajas&lt;/h2&gt;

&lt;h3 id=&quot;sistema-de-tipos&quot;&gt;Sistema de tipos&lt;/h3&gt;
&lt;p&gt;Esta no es una desventaja como tal de Go, sino una creada por el ecosistema de desarrollo actual: al haber tantos lenguajes que hacen manejo de valores y tipos de dato autom√°ticamente, al programar en &lt;em&gt;cualquier&lt;/em&gt; lenguaje tipado, incluyendo Go, muchos sienten que est√°n desperdiciando su tiempo.&lt;/p&gt;

&lt;h2 id=&quot;relativamente-joven&quot;&gt;Relativamente joven&lt;/h2&gt;

&lt;p&gt;Go tiene a penas 10 a√±os de haber salido a la luz, 12 desde que se empez√≥ a dise√±ar. El tiempo de vida de un lenguaje influye en su usabilidad y la conveniencia de varias formas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;La comunidad que ha desarrollado&lt;/li&gt;
  &lt;li&gt;Las herramientas disponibles&lt;/li&gt;
  &lt;li&gt;Los errores encontrados&lt;/li&gt;
  &lt;li&gt;Experiencias de otros desarrolladores con diferentes tipos y tama√±os de sistemas&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Considera esto si tienes que hacer un proyecto grande.&lt;/p&gt;

&lt;h2 id=&quot;proyectos-que-lo-usan&quot;&gt;Proyectos que lo usan&lt;/h2&gt;

&lt;p&gt;Muchos proyectos importantes del mundo de la infraestructura, orquestaci√≥n de servidores, contenedores, bases de datos y herramientas para programadores lo usan. Algunos ejemplos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Docker&lt;/li&gt;
  &lt;li&gt;Kubernetes&lt;/li&gt;
  &lt;li&gt;Terraform y Vault (casi todos las herramientas de HashiCorp)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.influxdata.com/&quot;&gt;InfluxDB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/caddyserver/caddy&quot;&gt;Caddy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Esto te deber√≠a dar una idea de la importancia de Go en el ecosistema de desarrollo. Grandes proyectos lo usan, grandes empresas lo usan.&lt;/p&gt;

&lt;h2 id=&quot;go-vs-rust&quot;&gt;Go vs Rust&lt;/h2&gt;

&lt;p&gt;Una discusi√≥n reciente es cu√°l de los dos lenguajes va a lograr efectivamente reemplazar a C, con caracter√≠sticas m√°s modernas y como un lenguaje m√°s adaptado a las necesidades actuales. Esto es pura opini√≥n: Rust es un mejor candidato para reemplazar a C por sus caracter√≠sticas de manejo de memoria. Pero Rust no es un lenguaje tan f√°cil de aprender o empezar com Go.
En Go puedes hacer muchas cosas que haces con C razonablemente bien, sin tanta complicaci√≥n y sin tener que manejar la memoria manualmente o semi-manualmente. La prueba est√° en todos los proyectos que manejan cosas de bajo nivel.&lt;/p&gt;

&lt;p&gt;M√°s adelante tendremos un art√≠culo de por qu√© deber√≠as aprender Rust.&lt;/p&gt;

&lt;h2 id=&quot;conclusi√≥n&quot;&gt;Conclusi√≥n&lt;/h2&gt;

&lt;p&gt;Go es un lenguaje relevante en 2019, 10 a√±os despu√©s de haber nacido y lo seguir√° siendo por muchos a√±os, sobre todo por los proyectos ya desarrollados en √©l y las caracter√≠sticas de las que hablamos en este art√≠culo. Aprenderlo te dar√° una herramienta m√°s para desarrollar programas que valgan la pena y cumplan con lo esperado.&lt;/p&gt;

&lt;p&gt;Pero como &lt;a href=&quot;https://fs.blog/about/&quot;&gt;Shane Parrish&lt;/a&gt; dice: Go es ‚Äúsimple pero no f√°cil‚Äù. Es sencillo empezar a programar con √©l, pero dominar sus conceptos requiere estudio y esfuerzo. Go se siente como una herencia de gente muy sabia haciendo un lenguaje para hacer cosas grandes. No te arrepentir√°s de aprenderlo.&lt;/p&gt;</content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="go" /><category term="golang" /><category term="lenguajes-de-programaci√≥n" /><summary type="html">Go es un lenguaje muy relevante en algunas √°reas del desarrollo de software. Aprende para qu√© deber√≠as usarlo y por qu√© te conviene aprenderlo.</summary></entry><entry><title type="html">Ultralearning: el arte del aprendizaje profundo</title><link href="https://blog.thedojo.mx/2019/08/13/lecciones-sobre-el-aprendizaje-de-manos-de-un-experto.html" rel="alternate" type="text/html" title="Ultralearning: el arte del aprendizaje profundo" /><published>2019-08-13T00:00:00-05:00</published><updated>2019-08-13T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2019/08/13/lecciones-sobre-el-aprendizaje-de-manos-de-un-experto</id><content type="html" xml:base="https://blog.thedojo.mx/2019/08/13/lecciones-sobre-el-aprendizaje-de-manos-de-un-experto.html">&lt;blockquote&gt;
  &lt;p&gt;¬øEn qu√© te convertir√≠as si aprendieras todo lo que deseas?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;¬øCu√°ntas cosas est√°n en tu lista de aprendizaje?&lt;/strong&gt; Todos tenemos una lista larga de temas, habilidades y curiosidades por aprender. Pero tenemos una cantidad igual de grande de obst√°culos para lograrlo: la falta de acceso a recursos de aprendizaje, la falta de tiempo, falta de motivaci√≥n, dificultad en estructura, entre muchas otras cosas.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.scotthyoung.com/&quot;&gt;Scott Young&lt;/a&gt; el autor de &lt;a href=&quot;https://www.scotthyoung.com/blog/ultralearning/&quot;&gt;Ultralearning&lt;/a&gt; fue muy amable al proporcionarme una copia de revisi√≥n antes de que saliera el libro que &lt;a href=&quot;https://amzn.to/361v2hu&quot;&gt;ya est√° a la venta&lt;/a&gt;, y en este art√≠culo quiero sintetizar las principales t√©cnicas que ense√±a para que puedas lograr aprender mejor.&lt;/p&gt;

&lt;p&gt;Pero primero, ¬øqui√©n es Scott Young y por qu√© deber√≠amos escucharlo? Se hizo famoso por estudiar el temario completo (o casi completo) del MIT para Computer Science que normalmente se cursa en 4 a√±os &lt;strong&gt;en s√≥lo 1&lt;/strong&gt;. Este proyecto ocupaba todo su tiempo, un mont√≥n de concentraci√≥n y t√©cnicas para aprender. Aqu√≠ es donde empez√≥ a desarrollar el concepto que presenta en el libro (me tomar√© la libertad de traducirlo): Ultra-aprendizaje. A partir de ah√≠ ha aprendido muchas m√°s cosas con el mismo estilo agresivo de aprendizaje y ha ayudado a otros a hacer lo mismo.&lt;/p&gt;

&lt;p&gt;Un proyecto de ultra-aprendizaje se define como un periodo de concentraci√≥n intensa que permite aprender de manera acelerada y profunda el tema que hayas elegido. Para realizar estos proyectos, Scott propone &lt;strong&gt;nueve principios&lt;/strong&gt;, tomando como base lo que aprendi√≥ de otras personas que han realizado proyectos similares a los de √©l pero tambi√©n los estudios m√°s recientes sobre el tema.&lt;/p&gt;

&lt;p&gt;Este libro te servir√° tanto si eres t√∫ el que desea aprender como si quieres ense√±arle a otras personas.
Veamos los nueve principios necesarios para realizar tu propio proyecto de ultra-aprendizaje.&lt;/p&gt;

&lt;h2 id=&quot;1-meta-aprendizaje&quot;&gt;1: Meta-aprendizaje&lt;/h2&gt;

&lt;p&gt;Podemos pensar en este principio como la etapa de planeaci√≥n. Tienes que investigar c√≥mo esto que quieres aprender lo han aprendido otras personas, que ruta de aprendizaje han seguido, cu√°les eran sus conocimientos previos, cu√°nto les tom√≥, etc. Para esto puedes investigar en internet o incluso conseguir una entrevista con una persona que tenga los conocimientos que t√∫ quieres.Todo lo que puedas obtener de esta informaci√≥n es √∫til.&lt;/p&gt;

&lt;p&gt;Tambi√©n tienes que buscar y entender la estructura del tema que quieres aprender, los subtemas principales, cu√°les son buenos recursos para aprender. Si encontraste un experto que te ayudara ya tienes cubierto gran parte de esto.&lt;/p&gt;

&lt;p&gt;Es entonces que tienes que reunir todos los recursos posibles de aprendizaje y &lt;strong&gt;trazar un plan, un mapa de aprendizaje&lt;/strong&gt;. En este periodo decidir√°s cu√°nto tiempo vas a dedicarle al proyecto y hasta d√≥nde llegar√°s. Muy importante porque un poco de investigaci√≥n te puede ahorrar mucho tiempo de ejecuci√≥n. Este principio te invita a reducir al m√°ximo posible lo que no sabes que no sabes sobre el tema.&lt;/p&gt;

&lt;h2 id=&quot;2-enfoque&quot;&gt;2: Enfoque&lt;/h2&gt;

&lt;p&gt;Este principio establece que para poder aprender efectivamente antes tenemos que agudizar nuestra capacidad de concentrarnos en un tema.&lt;/p&gt;

&lt;p&gt;El enfoque puede trabajarse en tres momentos diferentes:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Empezar a enfocarse en algo&lt;/li&gt;
  &lt;li&gt;Mantener el enfoque&lt;/li&gt;
  &lt;li&gt;Mejorar la calidad de nuestra concentraci√≥n&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Muchos autores coinciden en que la calidad y capacidad par concentrarse es uno de las claves para poder progresar en cualquier cosa, no s√≥lo en el aprendizaje.&lt;/p&gt;

&lt;p&gt;En el libro se dan sugerencias pr√°cticas para poder mejorar en las tres etapas de enfoque.&lt;/p&gt;

&lt;h2 id=&quot;3-aprendizaje-directo&quot;&gt;3: Aprendizaje directo&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Aquel que puede ir a la fuente no va s√≥lo por la jarra.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Es bueno aprender cosas leyendo, pero es mucho mejor aprenderlas aplicando lo que leemos o practicando directamente. Si quieres aprender a programar tienes que crear programas reales que funcionen. Si quieres aprender un idioma tienes que hablar o comunicarte con otras personas en ese idioma. Haciendo esto aprender√°s mucho m√°s r√°pido de lo que har√≠as s√≥lamente leyendo libros que relaten la experiencia de otros, o usando Duolingo.&lt;/p&gt;

&lt;p&gt;Practicar la habilidad directamente o poner en acci√≥n el conocimiento har√° que este sea m√°s profundo, √∫til y que lo recuerdes mejor.&lt;/p&gt;

&lt;p&gt;Este principio es muy importante y muchos de nosotros lo hemos vivido en nuestra experiencia escolar: nada de lo que no es ense√±aron es aplicable en el mundo real porque las habilidades necesarias para realizar el trabajo de verdad son muy diferentes a lo que se ve en los libros. Aunque el conocimiento adquirido puede servir como base, &lt;strong&gt;la pr√°ctica hace al maestro&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;4-ensayo&quot;&gt;4: Ensayo&lt;/h2&gt;

&lt;p&gt;Esta parte es una de las que a las personas en general menos le gusta: practicar o ensayar partes de la habilidad que sean dif√≠ciles, laboriosas o aburridas.&lt;/p&gt;

&lt;p&gt;Muchas veces nuestras habilidades est√°n topadas o detenidas por cierta parte del proceso, como si fuera un embudo deteniendo el flujo de l√≠quido. Para acabar con esto hay que practicar con la parte m√°s inc√≥moda de la habilidad.&lt;/p&gt;

&lt;p&gt;Esto incluye que descompongas la habilidad en diferentes sub-procesos que puedan ejecutarse individualmente y practicar cada uno por separado hasta que lo domines de manera razonable, uno tras otro, cada de los sub-procesos hasta terminarlos todos. Despu√©s hay que practicar de nuevo el proceso completo y medir nuestro desempe√±o.&lt;/p&gt;

&lt;p&gt;Esto es conveniente porque al trabajar sobre una parte espec√≠fica del proceso completo puedes liberar recursos mentales para mejorar de manera m√°s profunda y significativa en esa parte de la habilidad.&lt;/p&gt;

&lt;h2 id=&quot;5-recuperaci√≥n-de-la-informaci√≥n&quot;&gt;5: Recuperaci√≥n de la informaci√≥n&lt;/h2&gt;

&lt;p&gt;El principio de ‚Äúretrieval‚Äù consiste en intentar poner en pr√°ctica y ver si de verdad entendiste lo que acabas de aprender mediante pruebas reales, por ejemplo: usar las palabras de un nuevo idioma en conversaci√≥n, contestar preguntas de un examen o usar una nueva t√©cnica aprendida para programar.&lt;/p&gt;

&lt;p&gt;Esto ayudar√° a que recuerdes mejor lo aprendido y a que no te quedes con la sensaci√≥n de que has aprendido algo cuando no es la realidad. Poner a prueba tu conocimiento es la mejor manera de saber que s√≠ existe y de qu√© calidad es.&lt;/p&gt;

&lt;p&gt;Este principio pone de relieve algo: es mucho m√°s inc√≥modo ‚Äúprobarse‚Äù a uno mismo mediante imponerse alg√∫n obst√°culo, es una fuente de cansancio e incomodidad mental, lo cu√°l nos puede dejar con la sensaci√≥n de que no estamos aprendiendo o avanzando mucho. Pero estudios sobre esto demuestran que aunque s√≥lo leer puede dejar la sensaci√≥n de que entendimos y aprendimos mucho, la forma m√°s efectiva de aprender es poner a prueba el conocimiento y la sensaci√≥n de aprendizaje no est√° directamente ligada a cu√°nto aprendimos de verdad.&lt;/p&gt;

&lt;h2 id=&quot;6-retroalimentaci√≥n&quot;&gt;6: Retroalimentaci√≥n&lt;/h2&gt;

&lt;p&gt;Una forma importante de mejorar y aprender es tener a alguien o algo que te ayude a encontrar lo que est√° fallando en tu desempe√±o del tema de lo que est√©s aprendiendo.&lt;/p&gt;

&lt;p&gt;El ejemplo que Scott usa de una persona que aprendi√≥ a hablar en p√∫blico como su proyecto de ultra-aprendizaje y que recib√≠a retroalimentaci√≥n de un mentor que le dec√≠a exactamente d√≥nde fallaba. Al atacar estos puntos que una persona con m√°s experiencia le marcaba pudo llegar a ser un orador de clase mundial en muy poco tiempo.&lt;/p&gt;

&lt;p&gt;A nadie nos gusta escuchar nuestras fallas, pero es una parte  muy importante de aprender de manera efectiva.&lt;/p&gt;

&lt;p&gt;Pero no todo tipo de retroalimentaci√≥n es √∫til. Cuando esta informaci√≥n es sobre alguna cualidad personal o sobre tu persona directamente, en general es m√°s perjudicial que ben√©fico, puede llevarte hasta a abandonar la habilidad que estabas intentando aprender.&lt;/p&gt;

&lt;p&gt;Muy probablemente todos hemos experimentado este tipo de comentarios: ‚ÄúEres muy inteligente‚Äù, ‚ÄúNo eres bueno para esto‚Äù, ‚ÄúMejor ded√≠cate a otra cosa‚Äù. Este tipo de comentarios no aportan nada relevante y atacan o inflan el ego de la persona.&lt;/p&gt;

&lt;p&gt;Para que la retroalimentaci√≥n sea √∫til debe proveer informaci√≥n que gu√≠e las siguientes etapas de aprendizaje. Para lograr esto debe ser muy espec√≠fico y si es posible decirte c√≥mo mejorar en ese aspecto.&lt;/p&gt;

&lt;h2 id=&quot;7-retenci√≥n&quot;&gt;7: Retenci√≥n&lt;/h2&gt;

&lt;p&gt;No deber√≠amos echar agua en una bote con fugas. De igual manera, no vale la pena que leas y aprendas muchas cosas que despu√©s no podr√°s recordar porque las olvidaste r√°pidamente.&lt;/p&gt;

&lt;p&gt;En este principio Scott explica que tenemos que aprender y reconocer por qu√© olvidamos y atacar esas causas espec√≠ficas.&lt;/p&gt;

&lt;p&gt;¬øC√≥mo hacer para no olvidar el valioso conocimiento que con tanto trabajo ganamos?&lt;/p&gt;

&lt;p&gt;Scott propone varios m√©todos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Repetici√≥n espaciada&lt;/strong&gt;. Es un m√©todo que consiste en repasar la informaci√≥n un poco de tiempo despu√©s de haberla estudiado o aprendido por primera vez y repetir el proceso con cada vez m√°s tiempo de espacio.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Automatizaci√≥n&lt;/strong&gt;. Cuando aprendemos algo a tal grado que podamos decir que tenemos automatizada la habilidad (como andar en bicicleta), es muy poco probable que lo olvidemos.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Sobre-aprendizaje&lt;/strong&gt;. Practicar m√°s all√° de lo que es requerido para volverse bueno en algo o competente har√° que las cosas sean mucho m√°s dif√≠ciles de olvidar. Esto se puede hacer practicando hasta el cansancio una actividad clave o aprendiendo algo m√°s dif√≠cil que construya sobre la actividad principal, por ejemplo: aprender y practicar c√°lculo diferencial har√° que sobre-aprendas √°lgebra.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Mnem√≥nicos&lt;/strong&gt;. Estas es un t√©cnica que consiste en crear im√°genes v√≠vidas o palabras relacionadas con lo que estemos buscando aprender para poder recordarlo. Los mejores memoristas del mundo aplican esta t√©cnica para poder recordar grandes cantidades de informaci√≥n en poco tiempo.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Poder retener informaci√≥n es uno de los requisitos para que tu proyecto de ultra-aprendizaje valga la pena.&lt;/p&gt;

&lt;h2 id=&quot;8-intuici√≥n&quot;&gt;8: Intuici√≥n&lt;/h2&gt;

&lt;p&gt;La intuici√≥n es el producto una gran cantidad de experiencia acumulada. Para verdaderamente entender algo tenemos que desarrollar nuestra intuici√≥n en el tema. ¬øQu√© podemos hacer para desarrollarla?&lt;/p&gt;

&lt;p&gt;En esta secci√≥n del libro se habla de c√≥mo personas como Richard Feynman parecen hacer magia al resolver problemas de f√≠sica y de matem√°ticas. La principal caracter√≠stica de Feynman usada para resolver los problemas es su capacidad de identificar &lt;em&gt;los principios que est√°n en juego&lt;/em&gt;, adem√°s de la gran cantidad de informaci√≥n almacenada obtenida de otros problemas resueltos con anterioridad.&lt;/p&gt;

&lt;p&gt;¬øC√≥mo puedes desarrollar una intuici√≥n similar?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Resolver problemas dif√≠ciles. Muchas veces hu√≠mos de los problemas que nos parecen demasiado dif√≠ciles para nosotros, pero resolver problemas que rebasen nuestra habilidad puede darnos un entendimiento muy profundo del tema tratado.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Comprueba la informaci√≥n para entenderla. No te quedes s√≥lamente con la explicaci√≥n del libro, sino trata de demostrar que lo que est√°s aprendiendo es cierto.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Usa ejemplos concretos. Cuando trates con conceptos o temas abstractos, desde el principio establece un ejemplo al que le puedas ir aplicando los puntos que se van explicando. Esta concreci√≥n permitir√° desarrollar un mejor entendimiento del tema.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No te enga√±es a ti mismo. Cuando te falta conocimiento sobre un tema, generalmente tambi√©n te falta conocimiento para saber qu√© tan h√°bil eres. Esto quiere decir que el que no tengas dudas sobre un tema significa que lo sabes todo, sino m√°s bien que sabes muy poco. Hacer muchas preguntas es una manera de hacerle frente a este problema, aunque parezcan tontas.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Una forma muy efectiva de desarrollar un entendimiento real: la t√©cnica de Feynman. Esta consiste en intentar explicar el problema, soluci√≥n o concepto de la manera m√°s clara posible como para alguien que nunca ha visto nada relacionado con el tema.&lt;/p&gt;
&lt;h2 id=&quot;9-experimentaci√≥n&quot;&gt;9: Experimentaci√≥n&lt;/h2&gt;

&lt;p&gt;El verdadero conocimiento no se queda en llegar al punto en que otros te dijeron que deb√≠as llegar sino en ir m√°s all√°.&lt;/p&gt;

&lt;p&gt;Adem√°s, mientras m√°s aprendas de algo menos gu√≠a podr√°s recibir ya que hay menos personas y recursos en ese nivel, por lo que es algo requerido aprender a experimentar con maneras de generar conocimiento.&lt;/p&gt;

&lt;p&gt;Para experimentar en tu aprendizaje y resultados puedes intentar tres cosas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Variar los &lt;strong&gt;recursos de aprendizaje&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;Experimentar la &lt;strong&gt;t√©cnica de aprendizaje&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;Experimentar con tu &lt;strong&gt;estilo de trabajo y aprendizaje&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Experimentar te permitir√° convertirte en verdadero experto en el tema que est√©s queriendo dominar.&lt;/p&gt;

&lt;h2 id=&quot;conclusi√≥n&quot;&gt;Conclusi√≥n&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Completar un proyecto de este tama√±o te demuestra que tienes la habilidad de mejorarte y de sacarle buen provecho a tu vida. Te da la confianza de que puedes lograr cosas ambiciosas.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Esta es una de las frases m√°s inspiradoras del libro y creo que te da buenos motivos para empezar a pensar en tus propio proyecto de ultra-aprendizaje, adem√°s de los beneficios asociados al tema mismo que quieras aprender:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;¬øTe ayudar√° a conseguir un mejor trabajo o puesto?&lt;/li&gt;
  &lt;li&gt;¬øPodr√°s ser m√°s √∫til a tu familia, comunidad o amigos?&lt;/li&gt;
  &lt;li&gt;¬øDisfrutar√°s m√°s de tu tiempo libre o tendr√°s m√°s a consecuencia de esto?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sin duda todas estas razones son suficientes para intentarlo por lo menos.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‚ÄúHacer cosas dif√≠ciles, sobre todo cosas que tienen que ver con aprender, puede crecer el concepto que tienes de ti mismo‚Äù.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Esto a su vez, tendr√° efectos en otros campos de tu vida.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;¬øQui√©n te podr√≠as volver?&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;¬°A aprender!&lt;/p&gt;

&lt;p&gt;Puedes comprar el libro en &lt;a href=&quot;https://www.amazon.com.mx/Ultralearning-Outsmart-Competition-Accelerate-English-ebook/dp/B07K6MF8MD/&quot;&gt;Amazon&lt;/a&gt;.&lt;/p&gt;</content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="aprendizaje" /><category term="libros" /><category term="lectura" /><category term="rese√±as" /><summary type="html">Todos queremos aprender muchas cosas. Aprende un m√©todo que te permitir√° mejorar tus habilidades para adquirir conocimiento.</summary></entry><entry><title type="html">Entendiendo REST: conexi√≥n sin estado</title><link href="https://blog.thedojo.mx/2019/08/03/entendiendo-rest-servidor-sin-estado.html" rel="alternate" type="text/html" title="Entendiendo REST: conexi√≥n sin estado" /><published>2019-08-03T00:00:00-05:00</published><updated>2019-08-03T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2019/08/03/entendiendo-rest-servidor-sin-estado</id><content type="html" xml:base="https://blog.thedojo.mx/2019/08/03/entendiendo-rest-servidor-sin-estado.html">&lt;p&gt;Hemos venido hablando de las caracter√≠sticas que componen a un sistema REST. En el √∫ltimo art√≠culo &lt;a href=&quot;/2019/07/04/entendiendo-rest-arquitectura-cliente-servidor.html&quot;&gt;hablamos de la arquitectura cliente-servidor&lt;/a&gt;. Esta es la primera caracter√≠stica fundamental de un sistema REST. Ahora pasemos a la siguiente caracter√≠stica-limitante que Thomas Fielding establece para los sistemas REST: &lt;strong&gt;conexi√≥n sin estado&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;qu√©-es-el-estado-de-un-sistema&quot;&gt;¬øQu√© es el estado de un sistema?&lt;/h2&gt;

&lt;p&gt;El estado de una aplicaci√≥n son todos los datos que usa para operar en un momento determinado.&lt;/p&gt;

&lt;p&gt;Como ejemplo podemos pensar en una aplicaci√≥n de ventas en l√≠nea. El estado de esta aplicaci√≥n, para un usuario espec√≠fico son sus datos de identificaci√≥n, su bolsa de compras y los productos que ha estado viendo o que tiene en su lista de deseos, as√≠ como datos que no son identificables directamente desde la interfaz de usuario como los tokens de sesi√≥n, su historial de visita de las p√°ginas y productos (piensa en Amazon) y los productos que ha comprado anteriormente en esta p√°gina.&lt;/p&gt;

&lt;p&gt;Todos estos datos necesarios para operar tanto a nivel interno como para la interfaz de usuario son el estado de la aplicaci√≥n para este usuario. &lt;strong&gt;Puedes entender el estado como el contexto de una aplicaci√≥n&lt;/strong&gt;. Todas las aplicaciones y programas usables tienen uno. Entonces, ¬øa qu√© nos referimos con conexiones sin estado?&lt;/p&gt;

&lt;h2 id=&quot;conexi√≥n-sin-estado&quot;&gt;Conexi√≥n sin estado&lt;/h2&gt;

&lt;p&gt;Dando por supuesto que estamos trabajando en un sistema con arquitectura de red &lt;a href=&quot;/2019/07/04/entendiendo-rest-arquitectura-cliente-servidor.html&quot;&gt;cliente-servidor&lt;/a&gt;, las dos partes comparten la informaci√≥n (el estado) necesaria para realizar las operaciones. La pregunta es: ¬øen qu√© lado mantengo esta informaci√≥n durante la operaci√≥n? Damos por supuesto que el almacenamiento de informaci√≥n a largo plazo est√° localizado en alg√∫n lado del servidor. Pero en el momento de la operaci√≥n, ¬øqui√©n mantiene estos datos memoria operativa?&lt;/p&gt;

&lt;p&gt;En el ejemplo del que hablamos: ¬øqui√©n mantiene en memoria la bolsa de compras del usuario, el cliente (el navegador web) o el servidor? Cualquiera de los dos podr√≠a llevarlo a cabo. Veamos los dos casos, empecemos por una conexi√≥n que ‚Äúrecuerda‚Äù el estado.&lt;/p&gt;

&lt;p&gt;Imag√≠nate la siguiente conversaci√≥n:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cliente(C): Vamos a empezar a trabajar con el usuario &lt;em&gt;hectorip&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Servidor(S): De acuerdo&lt;/li&gt;
  &lt;li&gt;C: Dame su bolsa de compras&lt;/li&gt;
  &lt;li&gt;S: Tiene estos 5 art√≠culos guardados&lt;/li&gt;
  &lt;li&gt;C: Comprar todos los art√≠culos de su bolsa&lt;/li&gt;
  &lt;li&gt;S: Ok, ser√°n $500&lt;/li&gt;
  &lt;li&gt;C: el cliente quiere pagar&lt;/li&gt;
  &lt;li&gt;S: le he cobrado todo lo de su bolsa&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;El tipo de conversaci√≥n que acabamos de ver ser√≠a una &lt;strong&gt;conexi√≥n con estado&lt;/strong&gt;: cada uno de los mensajes depende del mensaje anterior para poder entender de qu√© est√°bamos hablando. Intenta leerla de regreso y lo notar√°s.&lt;/p&gt;

&lt;p&gt;Ahora veamos c√≥mo ser√≠a un conversaci√≥n que no recuerda los mensajes anteriores:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C: Dame la bolsa de compra de &lt;em&gt;hectorip&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;S: hectorip tiene estos 5 art√≠culos en su bolsa&lt;/li&gt;
  &lt;li&gt;C: hectorip quiere comprar todos los art√≠culos de su bolsa&lt;/li&gt;
  &lt;li&gt;S: Ok, ser√°n $500 por todos los art√≠culos de la bolsa de compra&lt;/li&gt;
  &lt;li&gt;C: hectorip quiere realizar un pago por $500 por los art√≠culos en su bolsa de compras&lt;/li&gt;
  &lt;li&gt;S: He cobrado $500 a hectorip por el pedido de los art√≠culos en su bolsa de compras&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Si revisamos la conversaci√≥n anterior, podemos entender cada mensaje le√≠do individualmente, sin necesitar el contexto completo de la conversaci√≥n.&lt;/p&gt;

&lt;p&gt;La primera conversaci√≥n (conexi√≥n con estado) tiene algunas ventajas claras:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Los mensajes son m√°s cortos&lt;/li&gt;
  &lt;li&gt;La conversaci√≥n es m√°s flu√≠da&lt;/li&gt;
  &lt;li&gt;Se transfiere menos informaci√≥n de un lado a otro&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pero tambi√©n tiene desventajas. ¬øQu√© pasa si esta conversaci√≥n se interrumpe y se intenta retomar? &lt;em&gt;Hay que empezar la conversaci√≥n desde cero.&lt;/em&gt; ¬øQu√© pasa si el servidor, por alg√∫n error olvida de lo que est√°bamos hablando? &lt;em&gt;Hay que reiniciar la conversaci√≥n.&lt;/em&gt; ¬øQu√© pasa si quiero continuar la compra en otro servidor? &lt;em&gt;Hay que reiniciar la conversaci√≥n con el nuevo servidor.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;caracter√≠sticas-de-conexi√≥n-sin-estado&quot;&gt;Caracter√≠sticas de conexi√≥n sin estado&lt;/h1&gt;

&lt;p&gt;Hablemos de las caracter√≠sticas de una conexi√≥n sin estado.&lt;/p&gt;

&lt;p&gt;La primera caracter√≠stica es que &lt;em&gt;no necesitamos&lt;/em&gt; que la conexi√≥n a nivel de sesi√≥n de red sea persistente, es decir, que se mantenga un canal de comunicaci√≥n abierto que pueda mantener en memoria la informaci√≥n de los procesos actuales.&lt;/p&gt;

&lt;p&gt;Segundo, no podemos (ni debemos) asumir que el servidor mantendr√° los datos del cliente autom√°ticamente por medio de reconocer al cliente. En cada una de las peticiones que se hacen al servidor, &lt;strong&gt;deben venir todos los datos necesarios para que el servidor mantenga realice la operaci√≥n&lt;/strong&gt;, no se puede confiar en que las peticiones anteriores transfirieron esa informaci√≥n y no es necesario repetirla.&lt;/p&gt;

&lt;p&gt;Hasta ahora parece que esto presenta m√°s problemas que ventajas. Revisemos por qu√© alguien querr√≠a trabajar con un sistema as√≠.&lt;/p&gt;

&lt;h2 id=&quot;ventajas-de-mantener-el-servidor-sin-estado&quot;&gt;Ventajas de mantener el servidor sin estado&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Replicaci√≥n de servidores&lt;/strong&gt;. Al no tener que mantener el estado o conexiones persistentes con una instancia del servidor, una conexi√≥n sin estado puede permitir que la petici√≥n sea atendida por cualquier instancia del c√≥digo del servidor que tenga el mismo c√≥digo que las peticiones anteriores, ya que toda la informaci√≥n necesaria para atender esas peticiones estar√° incluida.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Escalabilidad&lt;/strong&gt;. Esto es una consecuencia inmediata de la ventaja anterior: poder replicar los servidores permite distribuir la carga entre muchas computadoras y aplicar t√©cnicas de balanceo para poder atender a muchos m√°s clientes de lo que se podr√≠a en un sistema que requiera mantener estados.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Servicios m√°s sencillos&lt;/strong&gt;. Quitarle la responsabilidad de mantener el contexto de las operaciones actuales a los servicios hace que su c√≥digo sea m√°s sencillo y por lo tanto m√°s mantenible.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Menos carga en los servidores&lt;/strong&gt;. Al no tener que mantener conexiones persistentes, ni tener que mantener procesos o memoria relacionada con los clientes con los que est√° operando, se reduce la carga en memoria operativa de los servidores (te√≥ricamente). Esto tambi√©n implica que el servidor ni siquiera tiene que estar corriendo mientras no est√© activamente respondiendo una petici√≥n (como las funciones lambda).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;La siguiente imagen ilustra una t√©cnica com√∫n para atender a muchos clientes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_1200/v1564887852/PNG_image-428CDB12FF65-1_ojrpoo.png&quot; alt=&quot;Diagrama de replicaci√≥n de servidores&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;desventajas&quot;&gt;Desventajas&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Complejidad de las peticiones&lt;/strong&gt;. La complejidad de las peticiones aumenta al necesitar mantener en el cliente toda la informaci√≥n necesaria para reconstruir el estado en cada petici√≥n en un servidor desde cero. Por lo tanto, la complejidad de los clientes aumenta. y el tama√±o de las peticiones se incrementa.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Mayor carga en la red&lt;/strong&gt;. Como las peticiones son m√°s complejas y generalmente contienen m√°s informaci√≥n para poder recuperar el contexto efectivamente, el viaje de informaci√≥n en la red es mayor en tama√±o.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;conexiones-que-mantienen-estado&quot;&gt;Conexiones que mantienen estado&lt;/h2&gt;

&lt;p&gt;En los √∫ltimos a√±os la mayor√≠a de las conexiones que se levantan en programas creados con la arquitectura cliente-servidor son creados con conexiones que no mantienen el estado. Sin embargo, tambi√©n se puede mantener una conexi√≥n con estado en la arquitectura cliente-servidor. Hay varias formas de lograr esto, pero la principal caracter√≠stica es que debe haber una manera de relacionar al cliente que est√° solicitando los servicios con el servidor que est√° atendi√©ndolo, por lo general la manera de hacerlo es con conexiones persistentes que se mantienen abiertas mientras el proceso de uso de los servicios dura.&lt;/p&gt;

&lt;p&gt;Esto viene con sus propios retos, pero tecnolog√≠as actuales como &lt;a href=&quot;/2019/06/02/por-que-deberias-aprender-elixir.html&quot;&gt;Elixir&lt;/a&gt;, Phoenix y los WebSockets hacen el camino m√°s f√°cil. En otro post hablaremos de c√≥mo podemos aprovechar esta arquitectura y en qu√© casos nos conviene.&lt;/p&gt;

&lt;h2 id=&quot;conclusi√≥n&quot;&gt;Conclusi√≥n&lt;/h2&gt;

&lt;p&gt;La segunda caracter√≠stica definida de los sistemas REST es importante porque permite que los servicios sean m√°s confiables, disponibles y flexibles en tama√±o (escalables). Como cada decisi√≥n que se toma en el desarrollo, esta viene con sus propias desventajas: al hacer m√°s complejas las peticiones, la base de c√≥digo es m√°s dif√≠cil de mantener en general (del lado del cliente), pero permite caracter√≠sticas importantes en los sistemas que tienen que atender a una gran cantidad de clientes.&lt;/p&gt;

&lt;p&gt;En el siguiente art√≠culo hablaremos de la tercera caracter√≠stica de los sistemas REST: la capacidad de ser cachear informaci√≥n.&lt;/p&gt;</content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="REST" /><category term="stateless" /><category term="thomas-fielding" /><summary type="html">¬øC√≥mo mantener la informaci√≥n entre peticiones en un sistema REST? Entendamos las ventajas y desventajas</summary></entry><entry><title type="html">Entendiendo REST: Arquitectura cliente-servidor</title><link href="https://blog.thedojo.mx/2019/07/04/entendiendo-rest-arquitectura-cliente-servidor.html" rel="alternate" type="text/html" title="Entendiendo REST: Arquitectura cliente-servidor" /><published>2019-07-04T00:00:00-05:00</published><updated>2019-07-04T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2019/07/04/entendiendo-rest-arquitectura-cliente-servidor</id><content type="html" xml:base="https://blog.thedojo.mx/2019/07/04/entendiendo-rest-arquitectura-cliente-servidor.html">&lt;blockquote&gt;
  &lt;p&gt;El prop√≥sito de construir software no es crear una topolog√≠a de interacciones espec√≠ficas, o usar un tipo particular de componente; es crear un sistema que cumpla y exceda las necesidades de la aplicaci√≥n. - Thomas Fielding&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ya hablamos de las &lt;a href=&quot;/2019/06/15/entendiendo-rest-estilo-de-arquitectura.html&quot;&gt;motivaciones detr√°s del estilo arquitectural REST&lt;/a&gt;. Ahora empecemos con la primera de sus caracter√≠sticas o restricciones, que la empieza a definir: la arquitectura cliente-servidor.&lt;/p&gt;

&lt;h2 id=&quot;qu√©-es-la-arquitectura-cliente-servidor&quot;&gt;¬øQu√© es la arquitectura cliente-servidor?&lt;/h2&gt;

&lt;p&gt;Esta arquitectura de aplicaci√≥n divide un sistema en dos componentes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Cliente&lt;/strong&gt;: Es un programa o proceso que solicita un servicio y usa la informaci√≥n provista para sus propios objetivos.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Servidor&lt;/strong&gt;: Programa o proceso que ofrece un conjunto de servicios y espera por peticiones para ejecutar o dar estos servicios.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La principal caracter√≠stica de la arquitectura cliente-servidor es que logra una &lt;em&gt;separaci√≥n de responsabilidades clara&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;En palabras de &lt;a href=&quot;https://homepages.cwi.nl/~marcello/SAPapers/And91.pdf&quot;&gt;Gregory R. Andrews&lt;/a&gt;, el cliente es un proceso desencadenante mientras que el servidor es un proceso reactivo. Es decir el servidor no puede env√≠ar datos o empezar procesos que un cliente no le ha solicitado.&lt;/p&gt;

&lt;p&gt;La arquitectura b√°sica de un sistema cliente-servidor es esta:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/v1562699566/PNG_image-ABC17A5C0944-1_wpyk2e.png&quot; alt=&quot;Esquema cliente-servidor&quot; /&gt;&lt;/p&gt;

&lt;!-- Recordemos que todos los dise√±os o arquitecturas implican un intercambio de valor entre varias caracter√≠sticas, en este caso un poco de simplicidad por la separaci√≥n de responsabilidades claras. --&gt;

&lt;p&gt;Veamos sus ventajas y desventajas.&lt;/p&gt;

&lt;h2 id=&quot;ventajas&quot;&gt;Ventajas&lt;/h2&gt;

&lt;p&gt;Hablemos de los beneficios que trae usar la arquitectura cliente-servidor.&lt;/p&gt;

&lt;h3 id=&quot;separaci√≥n-clara-de-responsabilidades&quot;&gt;Separaci√≥n clara de responsabilidades&lt;/h3&gt;

&lt;p&gt;La funcionalidad del sistema se divide en dos partes (por lo menos), como el nombre lo indica en parte de dar los servicios (generalmente de datos) y la parte de atender al usuario (humanos o programa) final.&lt;/p&gt;

&lt;p&gt;El cliente y el servidor tienen funciones completamente distintas y cada uno puede cambiar por su lado sin afectar al otro, a esto le podemos llamar ‚Äúevoluci√≥n independiente‚Äù.&lt;/p&gt;

&lt;p&gt;El ejemplo que tenemos es el del navegador y las p√°ginas que visitamos normalmente en internet. Mientras sigan cumpliendo con el protocolo establecido de comunicaci√≥n (HTTP) van a poder seguir comunic√°ndose y transfiriendo informaci√≥n, sin interferir la manera en que est√©n implementados sus procesos internos.&lt;/p&gt;

&lt;h3 id=&quot;divisi√≥n-de-complejidad&quot;&gt;Divisi√≥n de complejidad&lt;/h3&gt;

&lt;p&gt;La misma divisi√≥n de la que hablamos en el punto anterior permite dividir la complejidad en dos partes por lo que cada una por su lado es m√°s f√°cil de entender y desarrollar que el sistema completo.&lt;/p&gt;

&lt;p&gt;Por lo tanto, se sigue el mismo principio que se usa para desarrollar software complejo en general: &lt;strong&gt;divide y vencer√°s&lt;/strong&gt;. Esto permite que podamos dividir el trabajo limpiamente en diferentes etapas de desarrollo o entre diferentes equipos, que lo √∫nico que requieren es una interfaz de comunicaci√≥n clara.&lt;/p&gt;

&lt;p&gt;Esto no quiere decir que la complejidad &lt;em&gt;general&lt;/em&gt; se reduzca. De esto hablaremos en las desventajas.&lt;/p&gt;

&lt;h3 id=&quot;m√∫ltiples-versiones-y-reusabilidad&quot;&gt;M√∫ltiples versiones y reusabilidad&lt;/h3&gt;

&lt;p&gt;La implementaci√≥n de la interfaz de comunicaci√≥n es el √∫nico requisito indispensable para que un sistema cliente-servidor pueda seguir funcionando. Esto permite que un servidor pueda tener un n√∫mero indefinido de clientes diferentes que puedan consumir su interfaz y viceversa. En el caso de REST implementar el servidor con la API permite crear tantos clientes como se necesite:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;p√°gina web&lt;/li&gt;
  &lt;li&gt;aplicaci√≥n m√≥vil&lt;/li&gt;
  &lt;li&gt;sistema embebido&lt;/li&gt;
  &lt;li&gt;SDK para servidores&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;S√≥lo para ilustrar:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1562294072/PNG_image-5618E8EA3C0D-1_vk18wv.png&quot; alt=&quot;Ilustraci√≥n de cliente-servidor multi-cliente&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tener N versiones de los clientes o poder crear una sin tener que volver a a replicar la funcionalidad del servidor ha hecho que las API‚Äôs se vuelvan sumamente populares.&lt;/p&gt;

&lt;h3 id=&quot;simplificaci√≥n-de-escalamiento&quot;&gt;Simplificaci√≥n de escalamiento&lt;/h3&gt;

&lt;p&gt;Poder tener separado el servidor permite que podamos escalarlo de forma independiente dependiendo del n√∫mero de clientes a los que va a atender. Si necesitamos dar un servicio a escala mundial podemos replicar nuestros servidores (usando las arquitecturas adecuadas para esto) sin afectar a los clientes y sin que ellos se enteren y por lo tanto tengan que hacer alg√∫n cambio.&lt;/p&gt;

&lt;h2 id=&quot;desventajas&quot;&gt;Desventajas&lt;/h2&gt;

&lt;p&gt;Todo en la vida viene con desventajas asociadas y generalmente directamente proporcionales a sus ventajas. Y otra vez: intercambiamos valor entre diferentes partes de la aplicaci√≥n. Analicemos algunas de estos intercambios que hacemos al aplicar la arquitectura cliente-servidor.&lt;/p&gt;

&lt;h3 id=&quot;complejidad-general-aumentada&quot;&gt;Complejidad general aumentada&lt;/h3&gt;

&lt;p&gt;Cuando dividimos la aplicaci√≥n y funciones completas en dos partes, aunque la complejidad de cada parte es menos que la general, la complejidad general aumenta porque hay que agregar elementos al sistema:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Interfaces de comunicaci√≥n entre cliente y servidor&lt;/li&gt;
  &lt;li&gt;Mantenimiento o forma de recuperaci√≥n del estado general de la aplicaci√≥n&lt;/li&gt;
  &lt;li&gt;Protocolos de comunicaci√≥n de red cuando es el caso&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;centralizaci√≥n-de-la-informaci√≥n&quot;&gt;Centralizaci√≥n de la informaci√≥n&lt;/h3&gt;

&lt;p&gt;El servidor es el responsable de almacenar la informaci√≥n y procesarla para darle servicio a los diferentes clientes que los soliciten, lo cual, aunque hace m√°s f√°cil su administraci√≥n, representa la desventaja de tener la informaci√≥n centralizada en el sistema que act√∫a como servidor. Si este sistema se corrompe de alguna forma, los clientes necesitan otras fuentes de informaci√≥n para eliminar este problema.&lt;/p&gt;

&lt;p&gt;Combinar cliente-servidor con otra arquitecturas ayuda a mitigar esta falla. Por ejemplo, se puede implementar el patr√≥n de replicaci√≥n de repositorio en el lado de los proveedores de servicio.&lt;/p&gt;

&lt;p&gt;Pero, un momento, ¬øacaso no es cliente-servidor la √∫nica arquitectura que existe para sistemas web o sistemas distribuidos?&lt;/p&gt;

&lt;h2 id=&quot;otras-arquitecturas&quot;&gt;Otras arquitecturas&lt;/h2&gt;

&lt;p&gt;La arquitectura para aplicaciones distribuidas m√°s escuchada es la cliente-servidor, pero no es ni de lejos la √∫nica. Analicemos otras dos arquitecturas comunes y d√≥nde se usan. Si quieres ver la lista completa que Fielding analiza puedes revisar la secci√≥n 2 de &lt;a href=&quot;https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf&quot;&gt;su tesis doctoral&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;peer-to-peer&quot;&gt;Peer to Peer&lt;/h3&gt;

&lt;p&gt;En este estilo est√° compuesta por nodos equivalentes, es decir, que tiene la misma funci√≥n (aunque pueden tener diferente informaci√≥n) y que se distribuyen la carga que soporta el sistema entero seg√∫n las capacidades de cada uno y a veces se proporcionan servicios entre ellos. Un mismo nodo puede cambiar entre funciones o roles en la red dependiendo de la demanda.&lt;/p&gt;

&lt;p&gt;En esta arquitectura no hay por definici√≥n un nodo m√°s importante que otro y si alguno de toda la red falla, puede ser sustituido por otro si tiene la informaci√≥n replicada.&lt;/p&gt;

&lt;p&gt;Las redes de torrents, el blockchain y programas como Ares o LimeWire funcionaban de esta forma.&lt;/p&gt;

&lt;p&gt;Una red peer-to-peer puede lucir as√≠:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_871/v1561266301/PNG_image-CC8B051C8851-1_r78hfc.png&quot; alt=&quot;Ejemplo de red peer to peer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Las redes peer-to-peer son una de las mejores formas de crear sistemas distribuidos resistentes y descentralizados, es decir, que no concentran la informaci√≥n en un s√≥lo punto que se vuelve el m√°s delicado e importante de todos.&lt;/p&gt;

&lt;h3 id=&quot;pipe-and-filter&quot;&gt;Pipe and Filter&lt;/h3&gt;

&lt;p&gt;En este patr√≥n, la informaci√≥n pasa por una series de ‚Äúfiltros‚Äù o nodos que la procesan y van dejando la informaci√≥n en un nuevo estado o con nuevas propiedades y que pasan la informaci√≥n al siguiente nodo. Este patr√≥n es el que siguen los pipelines de datos normalmente, en el que la informaci√≥n que es producida por una fuente externa es procesada a trav√©s de una serie de pasos, que pueden incluir la recolecci√≥n, limpieza, almacenamiento, etc.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_800/v1562217820/PNG_image-C00985E33227-1_mevaqa.png&quot; alt=&quot;Ilustraci√≥n de pipe and filter&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusi√≥n&quot;&gt;Conclusi√≥n&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Los estilos arquitect√≥nicos el dise√±o de un sistema deben adecuarse a las necesidades de ese sistema, no al rev√©s. - Thomas Fielding&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;¬øA qu√© necesidades nos adaptamos?&lt;/p&gt;

&lt;p&gt;A la necesidad de tener una separaci√≥n clara entre las funciones de datos y procesos de negocio y las interfaces de usuario: sean usuarios finales humanos u otros programas que consumen informaci√≥n.&lt;/p&gt;

&lt;p&gt;La arquitectura cliente-servidor permite simplificar el trabajo del lado del servidor al no tener que preocuparse por todas las distintas situaciones en las que sus datos o procesos van a ser usados.&lt;/p&gt;

&lt;p&gt;Esto nos lleva a que sus procesos sean &lt;strong&gt;reutilizables&lt;/strong&gt; por todos los clientes que sepan comunicarse con el servidor (l√©ase: usar su interfaz). A su vez los clientes son m√°s f√°ciles de crear por no tener en ellos mismos toda la l√≥gica del negocio y poder enfocarse en las funcionalidades de la entidad al que le van servir.&lt;/p&gt;

&lt;p&gt;Y por √∫ltimo, esta separaci√≥n permite que el servidor sea f√°cil de escalar al nivel del servicio requerido.&lt;/p&gt;

&lt;p&gt;Para los prop√≥sitos de REST la arquitectura Cliente-servidor es muy adecuada. Sus beneficios superan sus desventajas para este caso de uso particular.&lt;/p&gt;</content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="REST" /><category term="cliente-servidor" /><summary type="html">Hablemos de la arquitectura cliente-servidor y por qu√© es adecuada para REST.</summary></entry><entry><title type="html">Libros gratuitos para aprender an√°lisis de datos</title><link href="https://blog.thedojo.mx/2019/06/22/libros-gratuitos-para-aprender-analisis-de-datos.html" rel="alternate" type="text/html" title="Libros gratuitos para aprender an√°lisis de datos" /><published>2019-06-22T00:00:00-05:00</published><updated>2019-06-22T00:00:00-05:00</updated><id>https://blog.thedojo.mx/2019/06/22/libros-gratuitos-para-aprender-analisis-de-datos</id><content type="html" xml:base="https://blog.thedojo.mx/2019/06/22/libros-gratuitos-para-aprender-analisis-de-datos.html">&lt;p&gt;¬øQuieres aprender an√°lisis de datos y ya eres programador? Los siguientes libros pueden ser de gran ayuda. Este post est√° basado en &lt;a href=&quot;http://bit.ly/2RjPiol&quot;&gt;un art√≠culo ingl√©s que encontramos&lt;/a&gt;, pero con los recursos que recomienda actualizados y algunos otros de nuestra cosecha.&lt;/p&gt;

&lt;p&gt;Casi todos est√°n en ingl√©s pero inclu√≠mos unos cu√°ntos en espa√±ol y, en los que nos fue posible, tienes descarga directa.&lt;/p&gt;

&lt;h2 id=&quot;0-r-en-espa√±ol&quot;&gt;0. R en espa√±ol&lt;/h2&gt;

&lt;p&gt;Empecemos por los pocos recursos en espa√±ol. Encontr√© dos libros enfocados en aprender R (ojo: sin profundizar en el an√°lisis de datos) en espa√±ol.&lt;/p&gt;

&lt;h3 id=&quot;r-para-principiantes-de-juan-bosco-mendoza&quot;&gt;R para principiantes de Juan Bosco Mendoza&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://bookdown.org/jboscomendoza/r-principiantes4/images/r-principiantes-cover.png&quot; alt=&quot;Portada de R para principiantes&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;R para principiantes pretende ser un material introductorio al lenguaje de programaci√≥n R, dirig√≠do a personas que nunca han usado R o ning√∫n otro lenguaje de programaci√≥n, ni tiene conocimiento previo de probabilidad y estad√≠stica.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Es un libro que te lleva de la mano desde la instalaci√≥n hasta la exploraci√≥n visual de los datos, mediante el uso de la gr√°ficas generadas por R, de manos de un practicante asiduo del lenguaje.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bit.ly/2Ru1cvU&quot; target=&quot;_blank&quot;&gt;L√©e R para principiantes &lt;strong&gt;aqu√≠&lt;/strong&gt;.&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;r-para-principiantes-de-emmanuel-paradis-traducido-por-jorge-a-ahumada&quot;&gt;R para principiantes de Emmanuel Paradis, traducido por Jorge A. Ahumada.&lt;/h3&gt;

&lt;p&gt;Es una introducci√≥n al lenguaje R explicando un poco los detalles de funcionamiento para poder sentar las bases de uso avanzado, para principiantes en programaci√≥n. Toca algunas nociones muy b√°sicas de estad√≠stica para proporcionar ejemplos.&lt;/p&gt;

&lt;p&gt;Puedes &lt;a href=&quot;http://bit.ly/2RuQ02j&quot; target=&quot;_blank&quot;&gt;descargarlo &lt;strong&gt;aqu√≠&lt;/strong&gt;.&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;1-think-stats-segunda-edici√≥n&quot;&gt;1. Think Stats, Segunda Edici√≥n&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;The thesis of this book is that data combined with practical methods can answer questions and guide decisions under uncertainty.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Este libro ense√±a estad√≠stica b√°sica con Python y el proceso de an√°lisis de exploraci√≥n y an√°lisis de datos b√°sico, con un enfoque en los programas m√°s que en las matem√°ticas.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bit.ly/2Rlq20V&quot; target=&quot;_blank&quot;&gt;Lee Think Stats, segunda edici√≥n.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Extra: La editorial tiene todos sus libros para leer en formatos digitales gratuitos. Una oportunidad que no puedes perderte, s√≥lo que su sitio no es f√°cil de navegar as√≠ que visita la &lt;a href=&quot;https://greenteapress.com/wp/&quot; target=&quot;_blank&quot;&gt;p√°gina de inicio&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-bayesian-methods-for-hackers&quot;&gt;2. Bayesian Methods for Hackers&lt;/h2&gt;

&lt;p&gt;Este libro explica c√≥mo aplicar m√©todos de inferencia bayesiana para programadores que no tienen tanto conocimiento de estad√≠stica y matem√°ticas, enfocados en el lado de la programaci√≥n.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bit.ly/2Rs2TKt&quot; target=&quot;_blank&quot;&gt;Descarga el libro aqu√≠&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-undestarding-machine-learning-from-theory-to-algorithms&quot;&gt;3. Undestarding Machine Learning: From Theory to Algorithms&lt;/h2&gt;

&lt;p&gt;Este libro Shai Shalev-Shwartz y Shai Ben-David nos  ense√±an los fundamentos de machine learning y c√≥mo transformar estos principios en algoritmos &lt;em&gt;usables&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Este libro incluye un an√°lisis de la complejidad computacional implicada.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bit.ly/2Rr1Nys&quot; target=&quot;_blank&quot;&gt;Descarga Undestarding Machine Learning aqu√≠&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-the-elements-of-statistical-learning&quot;&gt;4. The Elements of Statistical Learning&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;‚ÄúEstamos inundados de informaci√≥n pero secos de conocimiento‚Äù - Rutherford D. Roger&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Esta frase que abre el libro explica la necesidad de entender y aplicar correctamente m√©todos estad√≠sticos de an√°lisis de datos para entender bien el mundo, dada la explosi√≥n de informaci√≥n que estamos viendo gracias a la digitalizaci√≥n de todas las industrias y de las ciencias.&lt;/p&gt;

&lt;p&gt;El libro se enfoca en los m√©todos de an√°lisis y sus fundamentos conceptuales en vez de en los detalles matem√°ticos.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stanford.io/2RtnVrX&quot; target=&quot;_blank&quot;&gt;Descarga The Elements of Statistical Learning&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-an-introduction-to-statistical-learning&quot;&gt;5. An Introduction to Statistical Learning&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://www-bcf.usc.edu/~gareth/ISL/ISL%20Cover%202.jpg&quot; alt=&quot;Portada del libro An Introduction to Statistical Learning&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Est√° dirigido a personas que no estudiaron algo relacionado con matem√°ticas (como la mayor√≠a de los programadores), para introducirlos a al aprendizaje estad√≠stico pr√°ctico, inspirado por el libro del punto 4.&lt;/p&gt;

&lt;p&gt;Este libro es adecuado para personas sin preparaci√≥n ni en estad√≠stica ni en ciencia de la computaci√≥n. Usa R para aprender los conceptos.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bit.ly/2RqyE6o&quot; target=&quot;_blank&quot;&gt;Descarga An Introduction to Statistical Learning&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;6-foundations-of-data-science&quot;&gt;6. Foundations of Data Science&lt;/h2&gt;

&lt;p&gt;Este libro intenta ense√±ar los fundamentos de an√°lisis de datos desde una perspectiva computacional, para darles a los lectores un fundamento para los siguientes 40 a√±os de la era de la computaci√≥n, argumentando que la primera √©poca, la enfocada en compiladores, algoritmos y lenguajes ha pasado y que ahora el foco deber√≠a estar en el an√°lisis y procesamiento de datos.&lt;/p&gt;

&lt;p&gt;Empieza estableciendo las bases matem√°ticas y el entendimiento necesario de los conceptos estad√≠sticos para luego avanzar a la aplicaci√≥n de estos.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bit.ly/2RtkNMI&quot; target=&quot;_blank&quot;&gt;Puedes descargarlo &lt;strong&gt;aqu√≠&lt;/strong&gt;.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;7-a-programmers-guide-to-data-mining&quot;&gt;7. A Programmer‚Äôs Guide to Data Mining&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/c_scale,w_570/v1561237264/mozi_c01gcv.png&quot; alt=&quot;Guide to data mining&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Es una gu√≠a pr√°ctica para miner√≠a de datos y sistema de recomendaci√≥n, con la t√©cnica de aprender haciendo, con ejercicions en Python. Es libro menos serio (en sentido de seriedad formal) de los que hemos visto hasta ahorita, tiene memes, bromas e im√°gines divertidas.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/v1561228640/Screenshot_2019-06-22_13.37.09_igbbp1.png&quot; alt=&quot;Blood, sweat and code&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bit.ly/2RtFCaY&quot; target=&quot;_blank&quot;&gt;Puedes descargar el libro aqu√≠&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;8-mining-of-massive-datasets&quot;&gt;8. Mining of Massive Datasets&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://i.stanford.edu/~ullman/gifs/mmds2.jpg&quot; alt=&quot;MMDS cover&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Este libro est√° basado en el curso &lt;a href=&quot;http://cs246.stanford.edu/&quot;&gt;CS246&lt;/a&gt; de Stanford del mismo nombre. Est√° enfocado en la miner√≠a de datos en grandes cantidades, es decir que no puedan ser mantenidos en la memoria principal.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‚ÄúData mining is about applying algorithms
to data, rather than using data to ‚Äútrain‚Äù a machine-learning engine of some
sort.‚Äù&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;En enfoque es en e los algoritmos que podemos aplicarle a los datos para obtener informaci√≥n relevante.&lt;/p&gt;

&lt;p&gt;Puedes descargar la &lt;a href=&quot;http://bit.ly/2RsGkoR&quot;&gt;segunda edici√≥n&lt;/a&gt; y ver el beta de la &lt;a href=&quot;https://stanford.io/2RAaJ4M&quot;&gt;tercera edici√≥n&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;9-deep-learning&quot;&gt;9. Deep Learning&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/v1561233648/Screenshot_2019-06-22_15.00.27_fxtwob.png&quot; alt=&quot;Deep learning cover book&quot; /&gt;
Es un recurso introductorio al campo de machine learning espec√≠ficamente enfocado en deep learning. 
Es un buen recurso para programadores que no tienen preparaci√≥n en estad√≠stica porque la primera parte del libro est√° enfocada en dar las bases matem√°ticas para comprender los algoritmos y t√©cnicas de deep learning.&lt;/p&gt;

&lt;p&gt;Puedes comprar el libro o leerlo directamente desde &lt;a href=&quot;http://bit.ly/2RtKtZK&quot;&gt;su p√°gina&lt;/a&gt; de forma gratuita.&lt;/p&gt;

&lt;h2 id=&quot;10-machine-learning-yearning&quot;&gt;10. Machine Learning Yearning&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/v1561236864/Screenshot_2019-06-22_15.54.12_r585on.png&quot; alt=&quot;ML Yearning&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Est√° escrito por &lt;a href=&quot;http://bit.ly/2RrkYYS&quot;&gt;Andrew Ng&lt;/a&gt; uno de los fundadores de Coursera y un gigante de la inteligencia artificial. Su enfoque principal es ense√±arte c√≥mo organizar un proyecto de Machine Learning, c√≥mo hacer que los algoritmos funcionen y den resultados.&lt;/p&gt;

&lt;p&gt;Te pide suscripci√≥n con correo electr√≥nico para que recibir una copia del borrador gratuita. Puedes &lt;a href=&quot;http://bit.ly/2RsPwtv&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;registrarte aqu√≠&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;11-los-libros-openintro&quot;&gt;11. Los libros OpenIntro&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/v1561234376/Screenshot_2019-06-22_15.11.04_m19ucx.png&quot; alt=&quot;Portadas OpenIntro&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OpenIntro es una iniciativa para proveer recursos de aprendizaje de alta calidad a un precio razonable.&lt;/p&gt;

&lt;p&gt;Provee todos sus recursos de manera gratuita para descarga. Puedes &lt;a href=&quot;http://bit.ly/2RxUIvZ&quot;&gt;&lt;strong&gt;visitarlos aqu√≠&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;12-los-libros-de-roger-d-peng-y-sus-colegas&quot;&gt;12. Los libros de Roger D. Peng y sus colegas&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/hectorip/image/upload/v1561235101/Screenshot_2019-06-22_15.24.56_xkx1qk.png&quot; alt=&quot;Roger D. Peng libros&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bit.ly/2Rvyg6Y&quot;&gt;Roger D. Peng&lt;/a&gt; es un profesor de bioestad√≠stica la 
Escuela Johns Hopkins Bloomberg de Salud P√∫blica. Tiene varios cursos en Coursera sobre an√°lisis de datos, y tambi√©n lo podemos considerar uno de los grandes contribuidores a la educaci√≥n sobre an√°lisis de datos.&lt;/p&gt;

&lt;p&gt;Ha escito numerosos libros sobre an√°lisis de datos y manejo de proyectos de an√°lisis de datos. Su especialidad es R.&lt;/p&gt;

&lt;p&gt;Puedes ver el &lt;a href=&quot;http://bit.ly/2Rrleai&quot;&gt;√≠ndice de sus libros &lt;strong&gt;aqu√≠&lt;/strong&gt;&lt;/a&gt;, casi todos ellos gratuitos, aunque puedes continuir monetariamente si gustas.&lt;/p&gt;

&lt;h2 id=&quot;conclusi√≥n&quot;&gt;Conclusi√≥n&lt;/h2&gt;

&lt;p&gt;Si sabes ingl√©s, hay m√°s material del que podr√≠amos leer decentemente en un buen tiempo sin tener que gastar un solo peso directamente en esta informaci√≥n. ¬øPor qu√© no aprovecharla?&lt;/p&gt;

&lt;p&gt;Cu√©antanos si ya le√≠ste uno de ellos y qu√© te pareci√≥.&lt;/p&gt;</content><author><name>H√©ctor Patricio</name><email>hectorivanpatriciomoreno@gmail.com</email><uri>https://github.com/hectorip</uri></author><category term="Machine Learning" /><category term="python" /><category term="r" /><summary type="html">Encuentra una colecci√≥n de libros gratuitos para aprender acerca de estad√≠stica, an√°lisis de datos y machine learning usando tanto Python como R.</summary></entry></feed>